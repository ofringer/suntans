%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% SUNTANS user guide.
%
% Oliver Fringer
% Stanford University
% 10 June 2004
%
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\documentclass[12pt,oneside]{article}
%\usepackage{amsfonts,graphics,/usr/share/texmf/tex/latex/misc/authordate1-4}
\usepackage{amsfonts,graphics}

%\newif\ifpdf\ifx\pdfoutput\undefined\pdffalse\else\pdfoutput=1\pdftrue\fi
%\newcommand{\pdfgraphics}{\ifpdf\DeclareGraphicsExtensions{.pdf,.jpg}\else\fi}

\textheight 8.0in
\textwidth 6in
\oddsidemargin 0.0in

\include{newcommands}

\begin{document}
%\pdfgraphics

\title{SUNTANS User Guide\\
{\large Stanford Unstructured Nonhydrostatic 
Terrain-following Adaptive Navier-Stokes Simulator}}
\author{O. B. Fringer\\
\small
Environmental Fluid Mechanics Laboratory,  \\
Stanford University\\
Stanford, CA 94305-4020
\normalsize}
\date{\today}

\maketitle

\tableofcontents

\section{Downloading and installing SUNTANS}

In order to use SUNTANS, you must also install the message-passing
interface (MPI), the parallel graph partitioning libraries (ParMetis~\cite{PARMETIS[1998]}),
the grid generation package Triangle~\cite{TRIANGLE[1996]}.  Instructions for 
downloading and installing these packages are available from the individual websites
for each package:
\begin{tabbing}
MPI\hspace{0.5in}\=  \verb+http://www-unix.mcs.anl.gov/mpi/mpich/+\\
ParMetis \> \verb+http://www-users.cs.umn.edu/~karypis/metis/parmetis/+\\
Triangle \> \verb+http://www-2.cs.cmu.edu/~quake/triangle.html+
\end{tabbing}
Note that you must compile the triangle libraries as object files by making them
with \verb+make trilibrary+.  Currently SUNTANS compiles and runs with Parmetis-2.0.

\subsection{Downloading and installing the latest source} \label{sec:download}

To obtain a copy of SUNTANS, download the latest version from the SUNTANS
web page at \verb+http://suntans.stanford.edu/downloads+.  Follow the following
steps to install the software.  {\bf Note: Do not continue beyond this point unless
you have installed the required packages mentioned in the previous paragraph!
SUNTANS will not compile unless you do so, even if you do not intend to run it in
parallel.}
\begin{enumerate}
\item First unpack the gzipped tar archive with
\begin{verbatim}
tar xzvf suntans-X.X.tgz
\end{verbatim}
where \verb+X.X+ is the latest version of SUNTANS.  
\item In the suntans-X.X directory, edit Makefile.in so that the directories containing the appropriate packages
are correctly specified as follows:
\begin{itemize}
\item \verb+MPIHOME+ should contain the base directory of the mpich distribution.
For example, 
\verb+MPIHOME=/usr/local/mpich-1.2.7+
\item \verb+PARMETISHOME+ should contain the base directory of the ParMetis distribution.
\item \verb+TRIANGLEHOME+ should contain the base directory of the Triangle libraries.
\end{itemize}
Note that there cannot be any spaces between the ``='' sign and the value.  As an example,
the \verb+Makefile.in+ file might look like
\begin{verbatim}
MPIHOME=/usr/local/mpich-1.2.7
PARMETISHOME=/usr/local/packages/ParMetis-2.0
TRIANGLEHOME=/usr/local/packages/triangle
\end{verbatim}
\item Once these locations are properly specified, compile the SUNTANS executable with
\begin{verbatim}
make
\end{verbatim}
This will create the main executable \verb+sun+.
\item Compile the SUNTANS graphical user interface with
\begin{verbatim}
make sunplot
\end{verbatim}
This will create the gui executable \verb+sunplot+.  Note:  This GUI requires the
existence of the \verb+Xlib+ libraries and it is assumed that these are located
in \verb+/usr/X11R6+.  Make sure the \verb+XINC+ and \verb+XLIBDIR+ variables
are specified correctly in the \verb+Makefile+ if \verb+sunplot+ does not compile.
\item In order to remove the object files, use
\begin{verbatim}
make clean
\end{verbatim}
\item To clean up the directory even further (remove \verb+*~, #*#, PI*, sun, sunplot+),
use
\begin{verbatim}
make clobber
\end{verbatim}
\end{enumerate}

\subsection{Keeping up to date with CVS}

You can keep an up to date copy of the SUNTANS distribution on your machine by using the
cvs repository.  To do so, you need to send your ssh public key to the suntans server administrator so that
it can be installed in the authorized keys file on the suntans server.  To obtain your
public key, use
\begin{verbatim}
ssh-keygen -t rsa
\end{verbatim}
This will create a public key in the file \verb+~/.ssh/id_rsa.pub+, which you should send
via email to the administrator.  You may use an empty passphrase but it is not recommended.
Once you send your public key to the suntans cvs administrator, in the \verb+bash+ shell, type
\begin{verbatim}
export CVSROOT=:ext:cvsuser@suntans:/home/cvs
export CVS_RSH=ssh
\end{verbatim}
This sets the \verb+CVSROOT+ environmental variable so that when you use the cvs commands
they look for the cvs repository on the suntans server as user cvsuser.
You will be granted read-only access to the cvs repository, so you can keep an up-to-date
copy of the latest source on your machine.  To check out the latest copy, type
\begin{verbatim}
cvs checkout suntans
\end{verbatim}
This will create the \verb+suntans+ directory and all of the subdirectories on the server.
If you would like to sync your copy of SUNTANS with the copy on the server, use
\begin{verbatim}
cvs update suntans
\end{verbatim}
Note that you are only allowed read access to the cvs server.  Any changes you make to
the SUNTANS files on your machine will not be updated on the server unless you are added
to the group list on the server.  You will also not be able to ssh into the server if you
try, as this will freeze your screen as only cvs access is allowed via ssh.

\section{Running {SUNTANS}}

Before running SUNTANS, you must have a valid triangulation and a valid parameter file \verb+suntans.dat+.
For details on the triangulation, see Section \ref{sec:grids}, and for details on the \verb+suntans.dat+
parameter file, see Section \ref{sec:suntans.dat}.  If you have a valid grid and parameter file in the same
directory as the \verb+sun+ executable, SUNTANS can be executed as a single processor job 
by running the main executable \verb+sun+ with
\begin{verbatim}
mpirun sun -t -g -s 
\end{verbatim}
Running with the input and output data files in the same directory as the source and executable
is in general not a good idea because SUNTANS creates many
input and output files that will clutter up the local directory.  It is best to create a new
directory and specify that directory as the working data directory on the command line and place the
grid and parameter files in that directory.  For
example, if the input files are in the local \verb+data+ directory, then SUNTANS would be
run with
\begin{verbatim}
mpirun sun -t -g -s --datadir=./data
\end{verbatim}
To run SUNTANS on multiple processors, use the \verb+-np+ flag with \verb+mpirun+. For example,
to run SUNTANS on 64 processors, use
\begin{verbatim}
mpirun -np 64 sun -t -g -s --datadir=./data
\end{verbatim}
The following is a list of flags that determine the behavior of the \verb+sun+ executable upon
running:
\begin{itemize}
\item{\verb+-t+} Create a triangulation from a planar straight line graph.  For details see
Section \ref{sec:grids}.
\item{\verb+-g+} Partition the triangulation among the given number of processors and
compute grid geometry and cell and processor connectivity.  For details see Section \ref{sec:grids}.
\item{\verb+-s+} Run the SUNTANS solver.
\item{\verb+-v[vvv]+} Output information about the progress of the run.  The more \verb+v+s, the
more verbose the output (maximum 4).
\item{\verb+-w+} Print out warnings that may lead to crashes or erroneous results to the screen
(independent of \verb+-v+).
\item{\verb+-r+} Restart SUNTANS from a previous run.  For details see Section \ref{sec:restart}.
\end{itemize}
A typical SUNTANS run with, for example, 4 processors, will proceed as follows:
\begin{enumerate}
\item Place the parameter file \verb+suntans.dat+ and planar straight line graph file in a directory,
say the \verb+data+ directory.
\item Create the triangulation and grid information with
\begin{verbatim}
mpirun -np 4 sun -t -g --datadir=./data
\end{verbatim}
This stores the grid information in files (see Section \ref{sec:grids}) for later reading later.
Since this process may take some time it is a good idea to run this once for large grids and
read in the grid data from a file.  
\item Read the grid data from the files and run the solver and output information about the
run with
\begin{verbatim}
mpirun -np 4 sun -s -vv --datadir=./data
\end{verbatim}
\item Once this run is finished it is possible to restart the run (for details see Section \ref{sec:restart})
with the data in \verb+data+ using
\begin{verbatim}
mpirun -np 4 sun -s -r -vv --datadir=./data
\end{verbatim}
\end{enumerate}

Note that the reason behind being able to specify the data directory at the command line is that
it enables the executable to be run from the same directory but to use data from different directories
that may contain different parameters.  For example, if the \verb+data1+ directory and \verb+data2+ 
directory contain different grid data (from previous calls to SUNTANS with the \verb+-t+ and \verb+-g+ flags),
then SUNTANS can be run either with
\begin{verbatim}
mpirun -np 4 sun -s --datadir=./data1
\end{verbatim}
or with
\begin{verbatim}
mpirun -np 4 sun -s --datadir=./data2
\end{verbatim}

\section{The main SUNTANS input file} \label{sec:suntans.dat}

The main SUNTANS input file is called \verb+suntans.dat+  and contains three
columns.  The first column contains the name of the variable used in
the program while the second column contains its value, and the information
after that value is ignored.  Lines beginning
with \verb #  are ignored, while {\bf empty lines will cause the program to 
crash}.  The SUNTANS executable looks for this file in the directory specified
by \verb+--datadir=+.  If this is not specified, then it looks for it in the
same directory as the \verb+sun+ executable.
A listing of the parameters in the \verb+suntans.dat+ file is given in
Section \ref{sec:params}.

\section{Creating or Reading in Triangular Grids} \label{sec:grids}

\subsection{Using the triangle libraries} \label{sec:tri}

Triangular grids can be created from a simple planar straight line
graph which is specified as the \verb+pslg+ file in \verb+suntans.dat+.
The format of this file is similar to the format of the planar straight
line graph file for use in triangle.  The planar straight line graph
file is a listing of points and edges which make up a closed contour.
These edges will comprise the boundaries of the triangulation that are
created by the triangle libraries.  The simplest PSLG file is one which
specifies a box with sides of length 1.  This requires four points and
four edges, as shown in the following file \verb+box.dat+:
\begin{verbatim}
# Number of points
4
# List of points (x,y,marker)
0.0 0.0 0
0.0 1.0 1
1.0 1.0 2
1.0 0.0 3
# Number of segments
4
# List of segments and boundary markers (point #, point #, marker)
0 1 1
1 2 1
2 3 1
3 0 1
# Number of holes
0
# Minimum area
.005
\end{verbatim}
The minimum area causes the triangle program to continue to add triangles
until the minimum area of one of the triangles satisfies this area.  
Setting the \verb+pslg+ variable to \verb+box.dat+ in \verb+suntans.dat+
and running SUNTANS with
\begin{verbatim}
mpirun sun -t -g --datadir=./data
\end{verbatim}
This creates a triangulation composed of 256 right triangles within a square
with sides of length 1.  The three columns after the number of points
specification correspond to the x,y coordinates of each point, along
with a marker for each point.  Following the number of segments specification,
the first two columns specify the indices of the points that make up
the end points of each segment in C-style numbering, such that the indices
go from 0 to one less than the number of points.  The third column in the
segment list specifies the marker for each segment.  This is how the boundary
conditions are specified, and is discussed in more detail in Section \ref{sec:boundary}.
The number of holes is currently not used.

Degenerate triangulations may arise when neighboring triangles are close to having
right angles.  In this case the distance between the Voronoi points may be close
to zero and hence may severely limit the time step.  This is remedied by setting
the \verb+CorrectVoronoi+ variable to 1 in \verb+suntans.dat+.  If this
parameter is set, then the Voronoi points are corrected when the distance
between Voronoi points is less than \verb+VoronoiRatio+ times the distance between
the cell centroids.  For example, for two neighboring right triangles, the Voronoi
points will be coincident and hence the distance between the Voronoi points of these
neighboring triangles will be zero.  If \verb+VoronoiRatio+ is set to \verb+0.5+, 
then the Voronoi points are adjusted so that the distance between them is half the
distance between the cell centroids.  If \verb+VoronoiRatio+ is set to \verb+1+,
then the Voronoi points correspond to the cell centroids.

\subsection{Reading Triangular Grids from a File} \label{sec:readgrid}

Use of the \verb+-t+ flag creates three files specified in \verb+suntans.dat+: 
\verb+points+, \verb+cells+, and \verb+edges+.  By default, these are specified
to be
\begin{verbatim}
points    points.dat
edges     edges.dat
cells     cells.dat
\end{verbatim}
The \verb+points+ file contains a listing of the x-y coordinates of the Delaunay points
in the full triangulation before being subdivided among different processors. 
This file contains three columns although the last column is never used.  The
total number of lines in this file is $N_p$, the number of triangle vertics in the triangulation.
The \verb+edges+ file contains $N_e$ rows each of which defines an
edge in the triangulation, and five columns in the following format:
\begin{verbatim}
Point1 Point2 Marker Voronoi1 Voronoi2
\end{verbatim}
\verb+Point1+ and \verb+Point2+ contain indices to points in the \verb+points+ file
and make up the end points of the Delaunay edges.  Because SUNTANS uses C-style
indexing, then $0\le$\verb+Point1,Point2+$<N_p$.  \verb+Marker+ specifies the type
of edge.  If \verb+Marker=0+, then it is a computational edge, otherwise, it is
a boundary edge, and the boundary condition is specified in Section \ref{sec:boundary}.
The last two entries, \verb+Voronoi1+ and \verb+Voronoi2+, are the indices to the Voronoi
points which make up the end points of the Voronoi edge which intersects this Delaunay edge.
As such, we must have $0\le$\verb+Voronoi1,Voronoi2+$<N_c$.
These Voronoi points correspond to triangles defined in the file \verb+cells+.  Voronoi points
which are ghost points are indicated by a $-1$.
The \verb+cells+ file contains $N_c$ rows each of which corresponds to a
triangle in the triangulation, and 8 columns in the following format:
\begin{verbatim}
xv yv Point1 Point2 Point3 Neigh1 Neigh2 Neigh3
\end{verbatim}
The \verb+xv+ and \verb+yv+ points correspond to the x-y coordinates
of the Voronoi points of each triangle and \verb+Point1+, \verb+Point2+, and \verb+Point3+
correspond to indices to points in the \verb+points+ file which make up the
vertices of the triangle.  These indices must satisfy \\
$0\le$\verb+Point1,Point2,Point3+$<N_p$. \\
\verb+Neigh1+, \verb+Neigh2+, and
\verb+Neigh3+ correspond to indices to neighboring triangles.  Neighboring
triangles which correspond to ghost points are represented by a $-1$.  For neighbors
not lying outside boundaries, we must have \\
$0\le$\verb+Neigh1,Neigh2,Neigh3+$<N_c$.\\
Because SUNTANS determines the number of triangle vertices $N_p$, edges $N_e$, and cells $N_c$
by the number of rows in the \verb+points+, \verb+cells+, and \verb+edges+ files, respectively,
it is important not to have extra carriage returns at the end of these files.

These three files are generated each time the \verb+-t+ flag is used with SUNTANS.  If
the \verb+-t+ flag is not used, then when called with $\verb+-g+$, SUNTANS reads these
three files and computes grid geometry and, if desired, partitions it among several processors.
The \verb+-g+ flag outputs the following data files, which are specified in \verb+suntans.dat+.
One file associated with each of these descriptors is created for each processor in a partitioned
grid.  For example, if the file name specified after \verb+cells+ in \verb+suntans.dat+ is given
by \verb+cells.dat+, then when called with 2 processors, the \verb+-g+ flag would output two files
names \verb+cells.dat.0+ and \verb+cells.dat.1+, each corresponding to the \verb+cells+ file of
each processor.
\begin{itemize}
\item \verb+cells+ Same as the output when using \verb+-t+, except on a per-processor basis.
The indices to the triangle vertices still correspond to indices in the global \verb+points+ file, which is
not distributed among the processors.  All other indices are local to the specific processor.
\item \verb+edges+ Same as the output when using \verb+-t+, except on a per-processor basis.
The indices to the end points of the edges still correspond to indices in the global \verb+points+ file, which is
not distributed among the processors.  All other indices are local to the specific processor.
\item \verb+celldata+ Contains the grid data associated with the Voronoi points of each cell and contains
$N_c$ rows, where $N_c$ is the number of cells on each processor (including interprocessor ghost points).
Each row contains the following entries:
\begin{verbatim}
xv yv Ac dv Nk Edge{1-3} Neigh{1-3} N{1-3} def{1-3}
\end{verbatim}
\begin{itemize}
\item \verb+xv yv+ are the Voronoi coordinates
\item \verb+Ac+ is the cell area
\item \verb+dv+ is the depth at the point \verb+xv,yv+.  This is the depth of the bottom-most
face of the column beneath this cell and is not the actual depth, which is always greater than
\verb+dv+.
\item \verb+Nk+ is the number of vertical levels in the water column.
\item \verb+Edge{1-3}+ are indices to the three edges that correspond to the faces of the cell.
\item \verb+Neigh{1-3}+ are the indices to the three neighboring cells.  
\item \verb+N{1-3}+ is the dot product of the unique normal with the outward normal on each
face.
\item \verb+def{1-3}+ is the distance from the Voronoi point to the three faces.
\end{itemize}
\item \verb+edgedata+ Contains the grid data associated with the Delaunay edges and contains
$N_e$ rows, where $N_e$ is the number of edges on each processor (including interprocessor edges).
Each row contains the following entries:
\begin{verbatim}
df dg n1 n2 xe ye Nke Nkc grad{1,2} gradf{1,2} mark xi{1,2,3,4} eneigh{1,2,3,4}
\end{verbatim}
\begin{itemize}
\item \verb+df+ is the length of the edge.
\item \verb+dg+ is the distance between the Voronoi points on either side of the edge.  If 
this is a boundary edge then \verb+dg+ is twice the distance between the edge and the Voronoi
point on the inside of the boundary.
\item \verb+n1,n2+ are the components of the normal direction of the edge.  These correspond
to the {\it unique} normals of each edge.  The outward normal for this edge corresponding to
a particular cell is given by \verb+n1*N, n2*N+, where \verb+N+ is the dot product of the
unique normal with the outward normal and is specified in the \verb+celldata+ file.
\item \verb+xe, ye+ are the coordinates of the intersection of the edge with the Delaunay
edge.  
\item \verb+Nke+ is the number of active edges in the vertical (see \verb+Nkc+).
\item \verb+Nkc+ is the maximum number of active cells in the vertical which neighbor a given edge.  \verb+Nkc+ is
always at least \verb+Nke+.  See Figure \ref{fig:nkenkc} for a graphical depiction.
\insertfig{.5}{figures/nkenkc}{Depiction of an edge in which Nke=4 and Nkc=6.}{fig:nkenkc}
item \verb+grad{1,2}+ are indices to the Voronoi points defined in the \verb+celldata+ file.
If $N_c$ is the number of cells on a processor, then $0\le$\verb+grad{1,2}+$<N_c$.
\item \verb+gradf{1,2}+ are indices that determine the location of the edge in the ordering
of the \verb+Edge{1-3}+ or \verb+def{1-3}+ arrays.  Each cell contains a pointer to this edge
in its list of \verb+Edge{1-3}+ pointers.  The \verb+gradf{1,2}+ index is a number from 
0 to 2 which determines which face number this edge is of a particular cell.
\item \verb+mark+ Contains the marker type for this edge.  All edges with the value 0 are
computational edges, while other values are described in Section \ref{sec:boundary}.
\end{itemize}
\item \verb+topology+
\begin{verbatim}
Np Nneighs neighbor{0,1,2,...,Np-1}\n
neigh0: num_cells_send num_cells_recv num_edges_send num_edges_recv
cell_send_indices ...
cell_receive_indices ...
edge_send_indices ...
edge_recv_indices ...
neigh1: num_cells_send num_cells_recv num_edges_send num_edges_recv
cell_send_indices ...
cell_receive_indices ...
edge_send_indices ...
edge_recv_indices ...
.
.
.
neigh{Numneighs-1}: num_cells_send num_cells_recv num_edges_send num_edges_recv
cell_send_indices ...
cell_receive_indices ...
edge_send_indices ...
edge_recv_indices ...
celldist[0] celldist[1] celldist[2] ... celldist[MAXBCTYPES-1]
edgedist[0] edgedist[1] edgedist[2] ... edgedist[MAXBCTYPES-1]
cellp[0],...,cellp[Nc-1]
edgep[0],...,edgep[Ne-1]
\end{verbatim}
\item \verb+vertspace+ Contains the vertical grid spacings.  This file has \verb+Nkmax+ rows,
where \verb+Nkmax+ is the number of z-levels.
\end{itemize}

\section{Specifying initial and boundary conditions} 

Initial and boundary conditions are specified by editing the files \verb+initial.c+ and \verb+boundaries.c+.  When you
edit either one of these files, you must recompile the SUNTANS executable in order for it to reflect changes made
to the initial or boundary conditions.

\subsection{Initial conditions}

Initial conditions are set by altering the functions in the file \verb+initial.c+ so that they return the
desired initial distributions.  There are five functions that specify the initial depth, free-surface,
salinity, temperature, and velocity fields.  Each function takes as its argument the x,y,z coordinates of
the desired initial condition.  You need to edit the function to return the desired initial value based on the
given x,y,z coordinates.  The five functions are
\begin{itemize}
\item \verb+ReturnDepth+ This returns the depth as a function of the given x,y coordinate. 
As an example, to set a linear slope that rises from 10 m depth to 1 m depth in 1000 m, the
function would look like
\begin{verbatim}
REAL ReturnDepth(REAL x, REAL y) {
  return 10 - 9*x/1000;
}
\end{verbatim}
Note that the depth is specified as a positive quantity.  This function is only used when the \verb+IntDepth+ variable is
set to \verb+0+ in \verb+suntans.dat+.  Otherwise, the depth is interpolated from the file specified by the \verb+depth+
file in \verb+suntans.dat+.  This file must contain the depth data in three columns given by x, y, depth, where depth
is specified as a negative quantity and elevation is positive.
\item \verb+ReturnFreeSurface+ This returns the initial free surface distribution as a function of the x,y coordinate.
As an example, to initialize the free surface with a 1 m cosine seiche in a 1000 m domain, the function would look like
\begin{verbatim}
REAL ReturnFreeSurface(REAL x, REAL y, REAL d) {
  return cos(PI*x/1000);
}
\end{verbatim}
Note that \verb+PI+ is a global variable defined in the file \verb+suntans.h+ as \verb+3.141592654+.  The depth
is also supplied to the \verb+ReturnFreeSurface+ function in case the free surface is a function of the depth.
\item \verb+ReturnSalinity+ and \verb+ReturnTemperature+  These are similar functions in that they return the
specified scalar field as a function of the x, y, and z coordinates.  Note that if \verb+beta+ is 0 in \verb+suntans.dat+,
then salinity transport is not computed, likewise if \verb+gamma+ is 0, then temperature transport is not computed.  
As it is now, the code computes the temperature as a passive scalar while the density anomaly $\rho$ is computed solely as a function of 
the salinity anomoly $s$, such that
\[\frac{\rho}{\rho_0}=\beta s\,.\]
\item \verb+ReturnHorizontalVelocity+ This returns the horizontal velocity defined at the faces of each cell.  The initial vertical velocity is
computed by continuity from this initial velocity field.  Since this function returns the velocity normal to a cell face, then
you must specify both velocity components \verb+u+ and \verb+v+ and then return the component normal to the face, which is
defined by the vector with components \verb+n1+ and \verb+n2+.  As an example, to return an irrotational vortex with
maximum velocity of 1, centered
about (x,y)=(5,5), the function would appear as
\begin{verbatim}
REAL ReturnHorizontalVelocity(REAL x, REAL y, REAL n1, REAL n2, REAL z) {
  REAL u, v, umag=1;

  u = -umag*(y-5)/5;
  v = umag*(x-5)/5;

  return u*n1+v*n2;
}
\end{verbatim}
\end{itemize}

\subsection{Specifying boundary conditions} \label{sec:boundary}

SUNTANS allows the specification of the velocity at the open boundaries in the file
\verb+boundaries.c+.  Boundary condition types on the velocity field can be specified in the \verb+pslg+ file
which sets the marker as described in Sections \ref{sec:tri} and \ref{sec:readgrid}.  The marker type
can be one of the following:
\begin{itemize}
\item \verb+1+ For closed boundaries.
\item \verb+2+ For open or velocity-specified boundaries.
\end{itemize}
If the marker is set to \verb+1+, then the velocity is set to \verb+0+ at those edges.  If it is set to \verb+2+,
then the velocity is specified in the file \verb+boundaries.c+.  This file loops through the edges whose edge
markers are \verb+2+.  As an example, consider the flow in a channel that is 1000 m long in which two boundaries
are specified as inflow and outflow and the other two are specified as solid walls, as shown in Figure 
\ref{fig:boundaries}.  
\insertfig{.5}{figures/boundaries}{Depiction of a channel with an inflow at $x=0$ m and outflow at $x=1000$ m with
the inflow/outflow boundaries specified with 2 markers and the solid walls with 1 markers.  The indices of
the cells adjacent to the boundaries are denoted by ib while the boundary cells have indices j.}{fig:boundaries}
Suppose you would like to
specify an incoming velocity that oscillates at a frequency $\omega$ due to an incoming wave at $x=0$ m and that
you would like to use the linearized open boundary condition to specify the outflow at $x=1000$ m.  Since the
edge markers at the inflow and outflow are the same, you need to set the boundary condition based on the x,y
location of the specified edge.  To do so, you would set up the functions in the \verb+boundaries.c+ file as follows
\begin{itemize}
\item Function OpenBoundaryFluxes:
\begin{verbatim}

  for(jptr=grid->edgedist[2];jptr<grid->edgedist[3];jptr++) {
    j = grid->edgep[jptr];

    ib = grid->grad[2*j];

    if(grid->xv[ib]>500) {
      for(k=grid->etop[j];k<grid->Nke[j];k++) 
         ub[j][k] = -phys->h[ib]*sqrt(GRAV/(grid->dv[ib]));
    } else {
      for(k=grid->etop[j];k<grid->Nke[j];k++) 
         ub[j][k]=phys->boundary_u[jptr-grid->edgedist[2]][k]*grid->n1[j]+
                  phys->boundary_v[jptr-grid->edgedist[2]][k]*grid->n2[j];
    }
 }

\end{verbatim}
\item BoundaryVelocities Function:
\begin{verbatim}

  for(jptr=grid->edgedist[2];jptr<grid->edgedist[3];jptr++) 
    j = grid->edgep[jptr];

    ib = grid->grad[2*j];

    if(grid->xv[ib]>500) {
      for(k=grid->etop[j];k<grid->Nke[j];k++) {
        phys->boundary_u[jptr-grid->edgedist[2]][k]=phys->uc[ib][k];
        phys->boundary_v[jptr-grid->edgedist[2]][k]=phys->vc[ib][k];
        phys->boundary_w[jptr-grid->edgedist[2]][k]=
            0.5*(phys->w[ib][k]+phys->w[ib][k+1]);
      } 
    } else {
      for(k=grid->etop[j];k<grid->Nke[j];k++) {
        phys->boundary_u[jptr-grid->edgedist[2]][k]=
            prop->amp*cos(prop->omega*prop->rtime);
        phys->boundary_v[jptr-grid->edgedist[2]][k]=0;
        phys->boundary_w[jptr-grid->edgedist[2]][k]=0;
        } 
    }
 }

\end{verbatim}
\end{itemize}
The outermost \verb+j+ loop loops over the edges which have boundary markers specified as \verb+2+.
The \verb+ib+ index is an index to the cell adjacent to the boundary edge.  Since the Voronoi points
are specified at the \verb+ib+ indices, then we need to specify the boundary condition based on
the location of the Voronoi points of the adjacent cell.  In this case the open boundary exists at x=1000, but since
we know that this boundary exists for boundary edges for $x>500$, we use the if statement
\verb+if(grid->xv[ib]>500)+ to specify these boundary edges.  The first part of the if statement
sets the flux at the open boundary over all the vertical levels with
\begin{verbatim}
      for(k=grid->etop[j];k<grid->Nke[j];k++) 
        ub[j][k] = -phys->h[ib]*sqrt(GRAV/(grid->dv[ib]));
\end{verbatim}
which is identical to 
\[ u_b = -h_b\sqrt{\frac{g}{d}} \,,\]
which is the linearized shallow-water free-surface boundary condition.  This loop uses
the \verb+Nke[j]+ variable, which is the number of vertical levels at face \verb+j+,
and \verb+etop[j]+, which is the index of the top level at the boundary.  The variable
\verb+etop[j]+ is usually \verb+0+ unless filling and emptying occur at the boundary
edges.  

In addition to setting
the boundary flux in the OpenBoundaryFluxes function, the user must also set the cartesian components
of velocity in the BoundaryVelocities function.  These are used to compute the advection of momentum.
At the open boundary, the boundary velocity components are set to the upwind value of the velocity
component.  For the u-component of velocity, for example, the boundary value is specified
with
\begin{verbatim}
phys->boundary_u[jptr-grid->edgedist[2]][k]=phys->uc[ib][k];
\end{verbatim}
Here, \verb+uc+ is the u-component of velocity at the Voronoi point with index \verb+ib+.

At the inlet, only the cartesian velocity components need to be specified.  In this example,
the u-component of velocity at the inlet is set with the code
\begin{verbatim}
phys->boundary_u[jptr-grid->edgedist[2]][k]=
               prop->amp*cos(prop->omega*prop->rtime);
\end{verbatim}
and the other components are set to 0.  This function uses the variables \verb+amp+ and \verb+omega+
which are set in \verb+suntans.dat+, and \verb+rtime+ is the physical time in the simulation.
The cartesian velocities which are specified at the inlet boundary are then used to compute
the flux in the OpenBoundaryFluxes function with
\begin{verbatim}
ub[j][k]=phys->boundary_u[jptr-grid->edgedist[2]][k]*grid->n1[j]+
         phys->boundary_v[jptr-grid->edgedist[2]][k]*grid->n2[j];
\end{verbatim}
This is just the dot product of the velocity field specified at the boundary with the
normal vector at the boundary edge, which points into the domain by definition.
Examples of how to employ velocity boundary conditions are described in Sections \ref{sec:boundary_ex}
and \ref{sec:internalwaves}.  Section \ref{sec:boundary_ex} also demonstrates 
how to specify salinity and temperature at the boundaries.

\section{Using the Sunplot GUI}

The Sunplot GUI is meant to be a debugging tool and hence it does not have the ability to output
results into a figure file, such as postscript, jpeg, or eps.  It is, however, a handy tool to
quickly view results without having to execute third-party software.  Sunplot has the ability to
view all of the data output from SUNTANS on several processors, and it only requires the X11 libraries.

This howto describes how to view the results presented in the two-dimensional wetting
and drying example and assumes that the data has been created in the respective data directory
in \verb+examples/wetdry/data+.  Details on how to create this data is given in Section \ref{sec:wettinganddrying},
and details on how to compile \verb+sunplot+ are described in Section \ref{sec:download}.

\subsection{Starting up the GUI}

The \verb+sunplot+ gui can be started while a simulation is running as long as the data files
are not empty.  To view the data with the default settings in a given directory, use
\begin{verbatim}
./sunplot --datadir=examples/wetdry/data
\end{verbatim}
This will bring up a planview of the salinity data at the first time step $n=1$ in the upper layer.$k=1$ (note
that the gui does not use C-style indexing, so the first index starts at k=1.), as shown in Figure
\ref{fig:sun1}
\insertfig{0.4}{figures/lock}{View of the Sunplot window upon first execution without any command
line options.}{fig:sun1}

\subsection{Moving around in time}

The three buttons beneath \verb+''Step: 1 of 41''+ on the upper left of the GUI control the time stepping.
\begin{list}{}
\item \button{$<--$}
\begin{list}{}
\item {\bf Left button:} Moves one step backward in time.
\item {\bf Middle button:} No effect
\item {\bf Right button:} Moves to time step 1.
\end{list}
\item \button{M}: 
\begin{list}{}
\item {\bf Left button:} Animates forward in time from begining to end.
\item {\bf Middle button:} Asks the user to input a desired time step at the command line.
\item {\bf Right button:} Animates backward in time from the end to the begining.
\end{list}
\item \button{$-->$};
\begin{list}{}
\item {\bf Left button:} Moves one step forward in time.
\item {\bf Middle button:} No effect
\item {\bf Right button:} Moves to the last step (in this case step 41).
\end{list}
\end{list}

\subsection{Displaying different vertical levels}

The two buttons beneath \verb+''Level: 1 of 20''+ on the upper left of the GUI control the vertical level
being shown.  Level 1 is the top level, while level 20 is level $N_{kmax}$.
\begin{list}{}
\item \button{$<--$}
\begin{list}{}
\item {\bf Left button:} Displays level up (decreasing k).
\item {\bf Middle button:} No effect
\item {\bf Right button:} Displays level 1.
\end{list}
\item \button{$-->$}:
\begin{list}{}
\item {\bf Left button:} Displays one level down (increasing k).
\item {\bf Middle button:} No effect
\item {\bf Right button:} Displays level $N_{kmax}$.
\end{list}
\end{list}

\subsection{Displaying different processors}

The three buttons beneath \verb+''Showing all 1 Procs''+ on the upper left of the GUI control the processor
being shown.  The default is to show all processors.  
\begin{list}{}
\item \button{$<--$}
\begin{list}{}
\item {\bf Left button:} Decreases the processor being displayed.  Loops around if on processor 1.
\item {\bf Middle button:} No effect
\item {\bf Right button:} Displays processor 1 (no C-style indexing).
\end{list}
\item \button{All}:
\begin{list}{}
\item {\bf Left button:} Displays all processors.
\item {\bf Middle button:} No effect.
\item {\bf Right button:} No effect.
\end{list}
\item \button{$-->$}:
\begin{list}{}
\item {\bf Left button:} Increases the processor number being displayed.  Loops around if on the last processor.
\item {\bf Middle button:} No effect
\item {\bf Right button:} Displays the last processor.
\end{list}
\end{list}

\subsection{Surface plots of data}

The default quantity to display is the salinity, or s, in planview, at level 1 and time step 1.  Color axes
are scaled to the minimum and maximum of the profile being shown.  The following
buttons control their respective plots:
\begin{list}{}
\item \button{S}: Salinity
\begin{list}{}
\item {\bf Left button:} Displays the salinity $s$.
\item {\bf Middle button:} Displays the salinity anomoly $s-s_0$.
\item {\bf Right button:} Displays the background salinity $s_0$.
\end{list}
\item \button{T}: Temperature
\begin{list}{}
\item {\bf Left button:} Displays the temperature $T$.
\item {\bf Middle button:} No effect.
\item {\bf Right button:} No effect.
\end{list}
\item \button{q}: Nonhydrostatic pressure
\begin{list}{}
\item {\bf Left button:} Displays the nonhydrostatic pressure $q$.
\item {\bf Middle button:} No effect.
\item {\bf Right button:} No effect.
\end{list}
\item \button{h}: Free surface
\begin{list}{}
\item {\bf Left button:} Displays the free surface $h$.
\item {\bf Middle button:} No effect.
\item {\bf Right button:} No effect.
\end{list}
\item \button{n}:  Eddy viscosity 
\begin{list}{}
\item {\bf Left button:} Displays the eddy viscosity $\nu_t$ at the center of the cell.
\item {\bf Middle button:} No effect.
\item {\bf Right button:} No effect.
\end{list}
\item \button{k}: Scalar diffusivity
\begin{list}{}
\item {\bf Left button:} Displays the scalar diffusivity $\kappa_t$ at the center of the cell.
\item {\bf Middle button:} No effect.
\item {\bf Right button:} No effect.
\end{list}
\item \button{U}: 
\begin{list}{}
\item {\bf Left button:} Displays the horizontal cartesian velocity component $u$, at the center of the cell.
\item {\bf Middle button:} No effect.
\item {\bf Right button:} Displays the horizontal cartesian baroclinic velocity component $u_b$, at the center of the cell.
This is calculated with
\[
u_b = u - \frac{1}{D}\int_{-D}^h u\,dz\,.
\]
\end{list}
\item \button{V}: 
\begin{list}{}
\item {\bf Left button:} Displays the horizontal cartesian velocity component $v$, at the center of the cell.
\item {\bf Middle button:} No effect.
\item {\bf Right button:} Displays the horizontal cartesian baroclinic velocity component $v_b$, at the center of the cell.
This is calculated with
\[
v_b = v - \frac{1}{D}\int_{-D}^h v\,dz\,.
\]
\end{list}
\item \button{W}: 
\begin{list}{}
\item {\bf Left button:} Displays the vertical cartesian velocity component $w$, at the center of the cell.
\item {\bf Middle button:} No effect.
\item {\bf Right button:} No effect.
\end{list}
\item \button{Depth}: 
\begin{list}{}
\item {\bf Left button:} Displays the depth d beneath the 0 datum.
\item {\bf Middle button:} No effect.
\item {\bf Right button:} Displays the water depth $h+d$.
\end{list}
\item \button{None}: 
\begin{list}{}
\item {\bf Left button:} No surface plot is shown.  Useful for only showing vector field.
\item {\bf Middle button:} No effect.
\item {\bf Right button:} No effect.
\end{list}
\end{list}

\subsection{Vector plots}

Vector plotting is controlled with the Vectors and the iskip and kskip buttons.
\begin{list}{}
\item \button{Vectors}:
\begin{list}{}
\item {\bf Left button:} Toggle vectors on/off.
\item {\bf Middle button:} Shorten the vectors by half their length.
\item {\bf Right button:} Double the length of the vectors.
\end{list}
\begin{list}{}
\item \verb+iskip/kskip+: Number of indices to skip to clarify the vector plot.
When in planview mode of the data, only every \verb+iskip+ vector on the unstructured
grid will be shown. Changing \verb+kskip+ has no
effect on the planview plot.
In profile mode, every \verb+iskip+ vector in the x-direction is shown and 
every \verb+kskip+ vector in the z-direction is shown.  The value of \verb+iskip+
and \verb+kskip+ are changed with their respective arrow buttons:
\begin{list}{}
\item \button{$<$}: Decrease skip amount.
\begin{list}{}
\item {\bf Left button:} Decrease skip by 1.
\item {\bf Middle button:} No effect.
\item {\bf Right button:} Set skip amount to 1.
\end{list}
\item \button{$>$}: Increase skip amount.
\begin{list}{}
\item {\bf Left button:} Increase skip by 1.
\item {\bf Middle button:} No effect.
\item {\bf Right button:} Planview mode: set skip amount to 5.  In profile mode, set skip
amount to maximum index size.
\end{list}
\end{list}
\end{list}
\end{list}

\subsection{Displaying the grid}

The grid can be viewed with the buttons \verb+Edges Voro Dela+.
\begin{list}{}
\item \button{Edges}:
\begin{list}{}
\item {\bf Left button:} Toggle display of Delaunay edges.
\item {\bf Middle button:} No effect.
\item {\bf Right button:} No effect.
\end{list}
\item \button{Voro}:
\begin{list}{}
\item {\bf Left button:} Toggle display of Voronoi points.
\item {\bf Middle button:} No effect.
\item {\bf Right button:} No effect.
\end{list}
\item \button{Dela}:
\begin{list}{}
\item {\bf Left button:} Toggle display of Delaunay points.
\item {\bf Middle button:} No effect.
\item {\bf Right button:} No effect.
\end{list}
\end{list}

\subsection{Zooming in on data and obtaining profile plots}

By default, zooming is on.  The effect of using the mouse and selecting a point on the
plotted data depends on whether zooming is on or off or if you are viewing a profile plot.
\begin{list}{}
\item \button{ZOOM}
\begin{list}{}
\item {\bf Left button:} Toggle turning zoom on/off.  
\begin{list}{}
\item When zooming is {\bf on}:
\begin{list}{}
\item {\bf Left button:}  Can be used either to select an area in the plot to zoom into, or
it can be used to zoom into an area by a factor of 2, centered about the clicking point.
\item {\bf Middle button:} Returns to the default in which the entire domain is displayed.
\item {\bf Right button:} Zooms out by a factor of 2.
\end{list}
\item When zooming is {\bf off}:
\begin{list}{}
\item {\bf Left button:}  Used to select a line along which a 2-d x-z transect of the data
is displayed.  Note that the transect uses a simple nearest-neighbor interpolation to
display the data in the transect.  If you press the mouse button once in the domain
while zooming is off, you may get a message that says \verb+''Cannot plot this slice''+.
This occurs because the length of the transect you have chosen is effectively zero by
clicking once on the plot window when zooming is off.
\item {\bf Middle button:} No effect.
\item {\bf Right button:} Displays the processor number and the value of the data at the selected point.
\end{list}
\end{list}
\item {\bf Middle button:} No effect.
\item {\bf Right button:} No effect.
\end{list}
\item \button{Profile}
\begin{list}{}
\item {\bf Left button:} This will toggle back and forth between the surface plot and the previous
transect that was displayed.  In the event that no transect has been displayed, the error
message \verb+Need two points for a profile first!+ will be displayed.  In this case, turn
zooming off and select two points for a profile.
\item {\bf Middle button:} Display the default west-east transect along the middle of the data set.
This is useful when you have a channel flow in the x-direction and want to see the data in
the x-z plane.
\item {\bf Right button:} Display the default north-south transect along the middle of the data set.
This is useful when you have a channel flow in the x-direction and want to see the cross-channel data in
the x-y plane.
\end{list}
\end{list}

\subsection{Changing the axes scaling}

By default, the x-y axes are scaled equally in ``Image'' mode (If the
\verb+-2d+ flag is supplied at the command line, however, the default mode is ``Normal'').  This
makes profile plots in x-z difficult to view especially for high
aspect ratio grids.  Hitting the \button{Aspect} button with the left
mouse button will toggle between ``image'' mode and ``normal'' mode,
in which the data is scaled to fit the plot area.  You can also do
this by hitting the ``a'' key.  The middle and right mouse buttons have
no effect here.

\subsection{Changing the color axes}

By default, the color axes are scaled with the maximum and minimum values of the data.
This can be changed with the Caxis button as follows:
\begin{list}{}
\item \button{Caxis}
\begin{list}{}
\item {\bf Left button:} Toggle between scaling with the maximum and minimum data values and
using the values specified in \verb+suntans.dat+.  Specifically, if you add the following
lines to your \verb+suntans.dat+ file, the data can be scaled with these color axes values
when pressing the Caxis button:
\begin{verbatim}
caxismin   -0.25      # Minimum value for color axes
caxismax    0.25      # Maximum value for color axes
\end{verbatim}
If these values are not in \verb+suntans.dat+, an error will be indicated each time data
is plotted until the Caxis button is hit again to return to the default scaling mode.
\item {\bf Middle button:} No effect.
\item {\bf Right button:}  Enter color axes values at the command line.  The format must be
in the form \verb+cmin cmax+ followed by a carriage return.  Carriage returns may also
exist between the entries of \verb+cmin+ and \verb+cmax+.
\end{list}
\end{list}

\subsection{Quitting out of sunplot}

You can either hit the \button{Quit} button or the ``q'' key to quit out of sunplot.

\subsection{Command line options}

Options can be passed to sunplot at the command line to reduce the number of key strokes
required to obtain a desired view of data.  The following is a list of command line arguments:
\begin{list}{}
\item \verb+--datadir=path+: This is the path to the directory containing the sunplot.dat
data file.  If this is not specified, then it is assumed that the data file is in the local
directory.
\item \verb+-np 2+: Specify the number of processors included in the data.  For a multi-processor
data set, if this is not specified then only the data from processor \verb+0+ will be displayed.
\item \verb+-2d+: Display an x-z profile plot of the data in axis Normal mode.  This is equivalent
to starting sunplot with no command line options and hitting the Axes button with the left mouse
button and the Profile button with the middle mouse button.
\item \verb+-g+: Only display the grid.  This is useful for debugging the grid without loading
in any other data.
\item \verb+-m+: Step forward through the data as an animation.
\end{list}

\section{Restarting Runs} \label{sec:restart}

It is always a good idea to design production-scale runs so that at any point in time if your
job crashes you can restart it without having lost too much data.  At the end of a run, SUNTANS
outputs the restart file specified by \verb+StoreFile+ in \verb+suntans.dat+.  To restart a run using
this restart file, you need to copy this file into the file specified by \verb+StartFile+ in \verb+suntans.dat+.
This reads the data required to continue a run.  For example, at the end of a two-processor run in which
the \verb+StoreFile+ variable is set to \verb+store.dat+, two restart files are created for each processor, 
namely \verb+store.dat.0+ and \verb+store.dat.1+.  To restart this run, set the entry for \verb+StartFile+ in
\verb+suntans.dat+ to \verb+start.dat+ and copy \verb+StoreFile+ to \verb+StartFile+ for each processor, i.e.
copy the contents of \verb+store.dat.0+ to \verb+start.dat.0+ and \verb+store.dat.1+ to \verb+start.dat.1+.

Since the new output data from the restart run will overwrite any existing data from a previous run, it is
a good idea to create a new directory for each restart run and copy the restart files into that directory.
Each run requires the \verb+suntans.dat+ file as well as other files for the grid as well, but rather than
copy these over to the new directory, it is best to create links to the already existing files in order
to save disk space.  In order for the restart run to proceed, links must be created for each of these
files (or copies):
\begin{itemize}
\item suntans.dat
\item celldata.dat.np
\item edgedata.dat.np
\item topology.dat.np
\item vertspace.dat
\end{itemize}
where \verb+np+ corresponds to each processor id.  Considering the previous example, to restart a run
one might create a new directory called \verb+run2+.  Then links could be made to the existing files 
with
\begin{verbatim}
ln -s suntans.dat run2/suntans.dat
ln -s celldata.dat.0 run2/celldata.dat.0
ln -s celldata.dat.1 run2/celldata.dat.1
ln -s edgedata.dat.0 run2/edgedata.dat.0
ln -s edgedata.dat.1 run2/edgedata.dat.1
ln -s topology.dat.0 run2/topology.dat.0
ln -s topology.dat.1 run2/topology.dat.1
ln -s vertspace.dat run2/vertspace.dat
\end{verbatim}
and then restarting SUNTANS (after copying the store files into run2) with
\begin{verbatim}
mpirun -np 2 sun -s -r --datadir=./run2
\end{verbatim}
where the \verb+r+ flag indicates a restart run.  An alternative method to perform a restart
is to create a new directory and then alter the entries in \verb+suntans.dat+ so that the
output files are specified by their full rather than relative paths.  For example, to set
the output directory so that SUNTANS outputs the free surface to the new directory \verb+run2+,
the entry for \verb+FreeSurfaceFile+ in \verb+suntans.dat+ could be changed from
\begin{verbatim}
FreeSurfaceFile   	fs.dat
\end{verbatim}
to
\begin{verbatim}
FreeSurfaceFile   	run2/fs.dat
\end{verbatim}

\section{SUNTANS Examples} \label{sec:examples}

\subsection{Running the examples}

Each example is located in one of the directories in the \verb+examples+ directory in
the main source directory.  As an example, consider the internal waves example located
in \verb+examples/iwaves+.  The internal waves simulation in this directory is defined by the following files
in the \verb+examples/iwaves+ directory:
\begin{itemize}
\item \verb+initialization.c+: Initial conditions
\item \verb+boundaries.c+: Boundary conditions
\item \verb+rundata/suntans.dat+: Parameters
\item \verb+rundata/pslg.dat+: Planar straight line graph
\end{itemize}
All examples are run in the same way.
The makefile in the \verb+iwaves+ directory compiles and links the initial and boundary condition
files with the main sun executable in the source directory.  Then it copies the parameter
file (\verb+suntans.dat+) and the planar straight line graph file to the directory \verb+data+ in
the particular example directory.  Then the main sun executable is run with
\begin{verbatim}
../../sun -t -g -s -vv --datadir=data
\end{verbatim}
where the particular flags may depend on the example, but the executable is run from
the main source directory and the data is local to the particular examples directory.
In order to compile and run an example, enter that example
directory and type \verb+make test+.  This will run the example simulation and place
the output data into the data irectory in the examples directory.
While the simulation is running, the data can be viewed from another command line
from the main source directory with
\begin{verbatim}
./sunplot --datadir=examples/iwaves/data
\end{verbatim}
It is important that you run \verb+make clobber+ between successive tests in other
test directories to ensure that you are recompiling the \verb+../../sun+ executable
with the correct initial and boundary condition files each time.  Without clobbering,
rerunning \verb+make test+ will run the test case while only reflecting changes in \verb+suntans.dat+.
Therefore, it is not necessary to clobber if the same test is being run with different 
parameters in \verb+suntans.dat+.

\subsection{Time accuracy} \label{sec:timeaccuracy}

This example is in the \verb+examples/accuracy+ directory and it
serves to verify the time accuracy of SUNTANS.  Details of the time accuracy
of SUNTANS and this particular test case can be found in Fringer\etal~\cite{FRINGER[2005]}.
The parameter file is given by
\verb+suntans.in+, which lacks the paramters \verb+dt+ and \verb+nsteps+.  These
are copied to the actual parameter file \verb+data/suntans.dat+ upon running the
script \verb+accuracy.sh+, which runs SUNTANS with different time steps and computes
accuracy criteria using the \verb+accuracy.c+ code.  This code is a good exmaple
of how to read in and analyze SUNTANS data using the C programming language.  More
details are given below.

\subsubsection{Grid}

The domain is 100 m long and 100 m deep, and it
uses 100 vertical levels and 100 equilateral triangles, as defined in the planar
straight line graph file \verb+rundata/oned.dat+, which was created with the
\verb+onedgrid.m+ m-file which can be downloaded from 

\medskip
\noindent
\mfiledownload.

\medskip
\noindent
All boundary edges are of type 1 (closed) boundaries.
The depth is constant and is defined in \verb+initialization.c+ in the 
\verb+ReturnDepth+ function with the line
\begin{verbatim}
return 100;
\end{verbatim}
Note that in order for this depth to be specified, the \verb+IntDepth+ parameter must
be set to 0 in the \verb+suntans.dat+ parameter file.

\subsubsection{Initial conditions}

The initial velocity field is quiescent, the initial free surface height is 0,
and the initial density distribution is defined in the function \verb+ReturnSalinity+
in \verb+initialization.c+ as
\begin{verbatim}
  return -.03*tanh(2.0*2.6467/20*(z+50-cos(PI*x/100)));
\end{verbatim}
Because $\beta=1$ in \verb+suntans.dat+ (the parameter \verb+beta+), this is also the initial density 
distribution, since $(\rho-\rho_0)/\rho_0 = \beta(s-s_0)$ More generally, then, 
this density distribution is given by
\[
\frac{\rho}{\rho_0} = -\frac{1}{2}\frac{\Delta\rho}{\rho_0}
\tanh\left[\frac{2\mbox{atanh}(\alpha)}{\delta}\left(z+\frac{D}{2}-\zeta\right)\right]\,,
\]
where
\begin{itemize}
\item $\Delta\rho/\rho_0=0.06$: Density difference between layers.
\item $\alpha=0.99$: Parameter that defines interface extent.
\item $\delta=20$ m: Interface thickenss.
\item $z$: Vertical coordinate
\item $D=100$ m: Depth
\item $\zeta = \cos(\pi x/L)$: Interface profile, where $L=100$ m is the domain length.
\end{itemize}
and is shown in Figure \ref{fig:initdens}. 
\insertfig{1}{figures/initdens}{Initial density distribution in $x$-$z$ (a) and as a profile at $x=L/2$ (b)
for the time accuracy test case.}{fig:initdens}

\subsubsection{Boundary conditions}

Because all boundaries of the planar
straight line graph (\verb+rundata/oned.dat+) are of type 1, the functions in the \verb+boundaries.c+ file are
not used in this example.

\subsubsection{Running the test}

The accuracy test case is run at the command line with
\begin{verbatim}
make test
\end{verbatim}
This will compile the local initial and boundary condition files and link them with the
executable \verb+../../sun+.  The script \verb+accuracy.sh+ loops through different
time step sizes given by $\Delta t_n = \Delta t_0/2^n$, with $n=0,1,\dots,5$, where
$\Delta t_0 = 0.1$ s.  If the reference solution is given by the solution $\phi^{ref}$
with a time step size of $\Delta t_0/32$, then the error between a solution using
$\Delta t=\Delta t_0/2^n$ and the 
reference solution can be calculated with
\[
Error(n)^2 = \frac{\sum_{i=0}^{Nc-1}\sum_{k=0}^{N_{kmax}-1} \left(\phi_{i,k}-\phi^{ref}_{i,k}\right)^2}
{\sum_{i=0}^{Nc-1}\sum_{k=0}^{N_{kmax}-1} \left(\phi^{ref}_{i,k}\right)^2}\,.
\]
Since this is a second-order method, we must have $Error(n)/Error(n-1)=4$ since the time step size
for $Error(n)$ is double that of $Error(n-1)$.  Therefore, $Error(n)/Error(0) = 4^n = (\Delta t_0/\Delta t_n)^2$,
$n=0,1,\dots,4$.  After
the \verb+accuracy.sh+ script finishes, the results are analyzed with the code in \verb+accuracy.c+,
which computes $Error(n)$.  The output of this code is given by
\begin{verbatim}
Error results (Error(n)/Error(0)):

Your results:
--------------------------------------------------
dt0/dt  U       W       S       Q       Q0      h
--------------------------------------------------
1       1.0     1.0     1.0     1.0     1.0     1.0
2       3.9     3.9     4.0     4.1     1.2     4.0
4       15.6    15.5    16.2    16.4    2.1     16.4
8       65.1    64.8    68.1    68.9    4.4     69.1
16      324.7   323.5   340.6   344.8   12.8    345.9

Reference results:
1       1.0     1.0     1.0     1.0     1.0     1.0
2       3.9     3.9     4.0     4.1     1.2     4.0
4       15.6    15.5    16.2    16.4    2.1     16.4
8       65.1    64.8    68.1    68.9    4.4     69.1
16      324.7   323.5   340.6   344.8   12.8    345.9

Difference (relative):
1       0.00    0.00    0.00    0.00    0.00    0.00
2       -0.00   0.00    0.00    0.00    0.00    -0.00
4       -0.00   0.00    0.00    0.00    0.00    -0.00
8       -0.00   0.00    0.00    0.00    0.00    -0.00
16      -0.00   0.00    0.00    0.00    0.00    -0.00
\end{verbatim}
The code outputs the results from the current run, then displays the results that
have been saved from a working version of this simulation, and then plots the relative
difference between your results and the stored results as
\[
\mbox{Difference} = \frac{\mbox{Your($Error(n)/Error(0)$)} - \mbox{Stored($Error(n)/Error(0)$)}}
{\mbox{Stored($Error(n)/Error(0)$)}}\,.
\]
Each column represents:
\begin{itemize}
\item \verb+dt0/dt+: $\Delta t_0/\Delta t^n$, $n=0,1,\dots 4$
\item \verb+U+: Horizontal velocity.
\item \verb+W+: Vertical velocity
\item \verb+S+: Salinity (or density, since $\beta=1$).
\item \verb+Q+: Nonhydrostatic pressure using the second-order Adams-Bashforth extrapolation
using the last two time steps (for details see Fringer\etal~\cite{FRINGER[2005]}).
\item \verb+Q0+: Nonhydrostatic pressure without the extrapolation of \verb+Q+.
\item \verb+h+: Free surface.
\end{itemize}
The first time you download and run the examples, the results
you obtain should be identical to the stored results since they were obtained with the
same code, and the relative difference should be identically zero.  Changing parts of the
code may or may not affect the accuracy, but if it does then this will be reflected by
nonzero values for the relative difference.

\subsection{Lock exchange} \label{sec:lockexchange}

This example is in the \verb+examples/lockexchange+ directory and it 
demonstrates the nonhydrostatic internal lock exchange problem.  Due to the
coarseness of the grid being used, numerical diffusion acts to limit the formation of
the KH billows along the interface.  These billows can easily be obtained by increasing
the resolution, following the simulation outlined by Fringer\etal~\cite{FRINGER[2005]}.

\subsubsection{Grid}

The grid in this example is also obtained with the 
\verb+onedgrid.m+ m-file which can be downloaded from 

\medskip
\noindent
\mfiledownload.

\medskip
\noindent
In this case, the grid contains 200 cells in the horizontal and 20 in the vertical, with
a length of 100 m and a depth of 20 m.  This constant depth is specified in \verb+initialization.c+
in the function \verb+ReturnDepth+ with the line
\begin{verbatim}
return 20;
\end{verbatim}
Note that in order for this depth to be specified, the \verb+IntDepth+ parameter must
be set to 0 in the \verb+suntans.dat+ parameter file.  As shown in Figure \ref{fig:stretched},
this grid is stretched in the
vertical in order to provide extra resolution at the bottom boundary.  This is done by
specifying a negative stretching factor of $r=-1.025$ (\verb+suntans.dat: rstretch = -1.025+),
which causes each grid layer to be 1.025 times thicker than the layer beneath it.  
\insertfig{0.8}{figures/stretched}{Depiction of the vertically stretched grid for the lock exchange
problem.  Every fourth vertical cell face plotted for clarity.}{fig:stretched}

\subsubsection{Initial conditions}

The initial velocity field is quiescent, the initial free surface height is 0,
and the initial density distribution is defined in the function \verb+ReturnSalinity+
in \verb+initialization.c+ as
\begin{verbatim}
  return -.001*tanh(2.0*2.6467/5*(x-50.0));
\end{verbatim}
Because $\beta=1$ in \verb+suntans.dat+ (the parameter \verb+beta+), this is also the initial density 
distribution, since $(\rho-\rho_0)/\rho_0 = \beta(s-s_0)$ More generally, then, 
this density distribution is given by
\[
\frac{\rho}{\rho_0} = -\frac{1}{2}\frac{\Delta\rho}{\rho_0}
\tanh\left[\frac{2\mbox{atanh}(\alpha)}{\delta}\left(x-\frac{L}{2}\right)\right]\,,
\]
where
\begin{itemize}
\item $\Delta\rho/\rho_0=2\times 10^{-3}$: Density difference.
\item $\alpha=0.99$: Parameter that defines interface extent.
\item $\delta=5$ m: Interface thickenss.
\item $x$: Horizontal coordinate.
\item $L=100$ m: Length
\end{itemize}
and is shown in Figure \ref{fig:initlock}. 
\insertfig{0.8}{figures/initlock}{Initial density distribution in $x$-$z$ (a) and as a profile at $x=L/2$ (b)
for the lock exchange test case.}{fig:initlock}

\subsubsection{Boundary conditions}

Because all boundaries of the planar
straight line graph (\verb+rundata/oned.dat+) are of type 1, the functions in the \verb+boundaries.c+ file are
not used in this example.

\subsubsection{Running the test and viewing the results}

This test case is run with the command
\begin{verbatim}
make test
\end{verbatim}
The simulation runs for 500 time steps (\verb+suntans.dat: nsteps = 500+) with a time step size of 0.2 s (\verb+suntans.dat: dt = 0.2+).
For this grid, given that the Voronoi distance for the equilateral triangles with sides of length $\Delta x=L/200$
is $D_g = \Delta x/\sqrt{3} = 0.2887$ m, and the maximum velocity is roughly $u_{max}=0.5$ m s$^{-1}$ (it actually
never exceeds $0.44$ m s$^{-1}$),
the horizontal Courant number is $C_x=u_{max}\Delta t/D_g = 0.35$, and the vertical Courant number is
$C_z=w_{max}\Delta t/\Delta z_{min}=0.2\mbox{m s}^{-1} 0.2\mbox{s}/0.78 m=0.05$.  Because central differencing
is employed for advection of momentum (\verb+suntans.dat: nonlinear = 2+), 
the horizontal grid Peclet number must satisfy the one-dimensional stability criterion which requires
that  $Pe_{\Delta x}<2/C_x$.  This is an approximation and is not as restrictive as it should be for multidimensional,
unstructured-grid problems, but it serves as a good approximation (See Fletcher~\cite{FLETCHER[1997]} for details).
For the horizontal stability, then, this requires that $\nu_H\ge u_{max}^2\Delta t/2 = 0.025$ m$^2$ s$^{-1}$ (\verb+suntans.dat: nuH = 0.025+).
Likewise, for vertical stability, $\nu = 0.016$  m$^2$ s$^{-1}$ (\verb+suntans.dat: nu = 0.016+).

The results can be viewed with the \verb+sunplot+ gui from the main source directory with
\begin{verbatim}
./sunplot --datadir=examples/lockexchange/data
\end{verbatim}
This will open up a planview of the one-dimensional grid of equilateral triangles, showing that
there are 26 (1+\verb+nsteps+/\verb+ntout+) time steps to plot.  To view the
profile plot, depress the \button{Profile} button with the middle mouse button.  The last time step
of the velocity vectors along with the salinity field can be viewed with the following buttons:
\begin{enumerate}
\item Right mouse on \button{$-->$}:  To get to last time step.
\item Left mouse on \button{Vectors}: Turn on velocity vectors.
\item 3$\times$ Right mouse on \button{Vectors}: Increase vector length by a factor of 8.
\item 2$\times$ Left mouse on \button{$>$}: Increase \verb+iskip+ to 3 to plot every third vector for clarity.
\end{enumerate}
The display should appear as it does in Figure \ref{fig:lock}.
\insertfig{0.6}{figures/lock}{Sunplot display of the lock exchange example after 500 time steps.}{fig:lock}

\subsection{Boundary condition example} \label{sec:boundary_ex}

This example is in the \verb+examples/boundaries+ directory and it simulates a simplified
river plume in order to demonstrate the use of velocity as well as scalar boundary conditions
at the inflow and the outflow.

\subsubsection{Grid}

The two-dimensional grid of equilateral triangles is created with the m-file \verb+twodgrid.m+,
which can be downloaded from
\medskip
\noindent
\mfiledownload.

\medskip
\noindent
As shown in Figure \ref{fig:plumegrid}, it is 3 km by 2 km with a total of 2430 equilateral triangles
with edge lengths of 75 m.  The eastern and southern boundaries
are marked as type 2 edges.  These will be specified in \verb+boundaries.c+.  The depth is
10 m and is specified in \verb+initialization.c+ as
\begin{verbatim}
return 10;
\end{verbatim}
There are 10 vertical levels (\verb+suntans.dat: Nkmax = 10+).
\insertfig{.8}{figures/plumegrid}{Two-dimensional planview of the river plume grid, showing the
boundary edges of type 2 in bold.}{fig:plumegrid}

\subsubsection{Initial conditions}

As specified in \verb+initialization.c+, the initial conditions are straightforward in
that all quantities are initialized to zero except the temperature field, which is a passive
tracer when $\gamma=1$ (\verb+suntans.dat: gamma = 1+).

\subsubsection{Boundary conditions}

\begin{itemize}
\item[] {\bf Eastern Boundary: open}\\
The eastern boundary fluxes normal to the faces are specified while values used for
advection of momentum and scalars are upwinded
\begin{itemize}
\item[] {\bf Boundary fluxes}\\
As specified in \verb+boundaries.c+, the eastern boundary is an open boundary and employs the
linearized boundary condition on the velocity as
\[ u_b = -h_b\sqrt{\frac{g}{d}} \,,\]
This is enforced in the \verb+OpenBoundaryFluxes+ function with the lines
\begin{verbatim}
if(grid->yv[ib]>50) {
   for(k=grid->etop[j];k<grid->Nke[j];k++) 
     ub[j][k]=-phys->h[ib]*sqrt(GRAV/grid->dv[ib]);
...
\end{verbatim}
The \verb+ib+ index is the index of the cell adjacent to the boundary, and the if statement
is required to distinguish this eastern outflow boundary from the southern boundary.
\item[] {\bf Boundary velocities}\\
At the eastern open boundary, the boundary velocities which are used for advection of momentum
out of the domain are given by the upwind velocity components.  This is specified in the
\verb+BoundaryVelocities+ function with the lines
\begin{verbatim}
if(grid->yv[ib]>50) {
   for(k=grid->etop[j];k<grid->Nke[j];k++) {
      phys->boundary_u[jptr-grid->edgedist[2]][k]=
                                  phys->uc[ib][k];
      phys->boundary_v[jptr-grid->edgedist[2]][k]=
                                  phys->vc[ib][k];
      phys->boundary_w[jptr-grid->edgedist[2]][k]=
                             0.5*(phys->w[ib][k]+phys->w[ib][k+1]);
   } 
\end{verbatim}
Because the flux of momentum is calculated at the vertical centers of the vertical faces,
the upwind vertical velocity is interpolated from the upper (k) and lower (k+1) faces of the kth cell.
\item[] {\bf Boundary scalars}\\
The outflow conditions on the scalars are imposed by specified the upwind scalar quantity
at the outflow face.  This is set in the funciton \verb+BoundaryScalars+ with the lines
\begin{verbatim}
for(k=grid->ctop[ib];k<grid->Nk[ib];k++) {
   phys->boundary_T[jptr-grid->edgedist[2]][k]=phys->T[ib][k];
   phys->boundary_s[jptr-grid->edgedist[2]][k]=phys->s[ib][k];
}
\end{verbatim}
\end{itemize}
\end{itemize}

\begin{itemize}
\item[] {\bf Southern boundary: specified}\\
All quantities at the southern boundary are specified.  Since this example simulates a river
inflow, the velocity and scalar field in only part of the southern boundary is specified, while
the rest is kept at zero inflow to represent a solid boundary.  This requires if-statements to
determine which of the southern boundary edges fall between the extent of the inflowing river.
An alternative is to set the markers of the southern boundary edges that fall within the boundaries
of the river to 2, and the rest to 1.
\begin{itemize}
\item[] {\bf Boundary fluxes}
Because the velocity components at the southern boundary are specified, the incoming boundary
flux is computed in \verb+OpenBoundaryFluxes+ using the velocity components specified in the \verb+BoundaryVelocities+ function,
but only within the extent of the 300 m wide river, which is defined for $900 < x < 1200$ m (4 cell faces), as in:
\begin{verbatim}
if(grid->xv[ib]>900&&grid->xv[ib]<1200)
  for(k=grid->etop[j];k<grid->Nke[j];k++) 
    ub[j][k]=
      phys->boundary_u[jptr-grid->edgedist[2]][k]*grid->n1[j]+
      phys->boundary_v[jptr-grid->edgedist[2]][k]*grid->n2[j];
\end{verbatim}
Since \verb+boundary_u+ and \verb+boundary_v+ store the inflow velocity components, then this
is setting the flux at the inflow to the normal component of the velocity at the inflow, i.e.
\[
U_{inflow} = {\mathbf u}_{inflow}\cdot {\mathbf n}_{inflow}\,,
\]
where ${\mathbf n}_{inflow}$ is, by convention, the inward pointing normal at the boundary face.
\item[] {\bf Boundary velocities}
The north-south velocity is specified at the inflow for $900 < x < 1200$ over a specified depth,
which represents the river inflow, such that
\begin{eqnarray}
u_{inflow} &=& 0\,,\nonumber\\
v_{inflow} &=& \left\{\begin{array}{ll}
                    \mbox{amp} & z>-D_r \\
		    0 & \mbox{otherwise\,,}
		    \end{array}
             \right.\nonumber\\
w_{inflow} &=& 0\,.\nonumber
\end{eqnarray}
where amp is specified in \verb+suntans.dat+ as $0.01$ m s$^{-1}$.  In \verb+boundaries.c+, this inflow is implemented with
\begin{verbatim}
if(grid->xv[ib]>900 && grid->xv[ib]<1200) {
  z=0;
  for(k=grid->etop[j];k<grid->Nke[j];k++) {
    z-=grid->dzz[ib][k];
    if(z>-5)
      phys->boundary_v[jptr-grid->edgedist[2]][k]=prop->amp;
    z-=grid->dzz[ib][k];
  }
}
\end{verbatim}
And all other components are set to zero at the beginning of the main loop in the function \verb+BoundaryVelocities+
with
\begin{verbatim}
for(k=grid->etop[j];k<grid->Nke[j];k++) {
  phys->boundary_u[jptr-grid->edgedist[2]][k]=0;
  phys->boundary_v[jptr-grid->edgedist[2]][k]=0;
  phys->boundary_w[jptr-grid->edgedist[2]][k]=0;
}
\end{verbatim}
\item[] {\bf Boundary scalars}
The inflow boundary condition for the salinity (or density, when $\beta=1$) field
represents an inflow of fresh water with a density anomoly of $\Delta \rho/\rho_0=-10^{-4}$, with a surface depth of $D_r=5$ m,
such that
\[
\rho_{inflow} = \left\{\begin{array}{ll}
                    \Delta \rho & z>-D_r \\
		    0 & \mbox{otherwise\,.}
		    \end{array}
             \right.
\]
The inflow boundary condition for temperature is a no-gradient condition, and as a result the temperature
just outside the boundary is equal to that just inside the boundary.  These boundary conditions for salinity (density)
and temperature are given in \verb+boundaries.c+ as
\begin{verbatim}
if(grid->yv[ib]<50)
  if(grid->xv[ib]>1000 && grid->xv[ib]<1200)
    for(k=grid->ctop[ib];k<grid->Nk[ib];k++) {
      z-=0.5*grid->dzz[ib][k];
      if(z>-5) {
        phys->boundary_T[jptr-grid->edgedist[2]][k]=phys->T[ib][k];
        phys->boundary_s[jptr-grid->edgedist[2]][k]=-0.0001;
      } else {
        phys->boundary_T[jptr-grid->edgedist[2]][k]=phys->T[ib][k];
        phys->boundary_s[jptr-grid->edgedist[2]][k]=0;
      }
      z-=0.5*grid->dzz[ib][k];
    }
\end{verbatim}
\end{itemize}
\end{itemize}

\subsubsection{Running the test}

Upon typing \verb+make test+, the simulation runs for a total of 3000 time steps (\verb+suntans.dat: nsteps = 3000+)
with a time step of 60 s (\verb+suntans.dat: dt = 60+), outputting
data every 120 time steps (\verb+suntans.dat: ntout = 120+).  While the data is running you can view the
results from the main source directory with
\begin{verbatim}
./sunplot --datadir=./examples/boundaries/data
\end{verbatim}
As can be seen from the results, the river plume forms a bulge as well as a coastal current resulting from
the nonzero Coriolis parameter of $f=5\times 10^{-4}$ (\verb+suntans.dat: Coriolis_f = 5e-4+).
After 3000 time steps, the density anomoly at the upper layer is depicted in Figure \ref{fig:plume}.  This
figure was obtained using the m-file \verb+sunsurf.m+, which can be downloaded from

\medskip
\noindent
\mfiledownload.

\medskip
\noindent
If you are running this m-file from the \verb+examples/boundaries+ directory, then the plot in Figure \ref{fig:plume}
was obtained with the command
\begin{verbatim}
timestep = 26;
klevel = 1;
processor = 0;
sunsurf('s','.../data',timestep,klevel,processor);
\end{verbatim}
Note that \verb+sunsurf.m+ requires \verb+unsurf.m+. 
\insertfig{0.8}{figures/plume}{River plume example showing the salinity (density) field after 3000 time steps.}{fig:plume}

\subsection{Wetting and drying} \label{sec:wettinganddrying}

\subsubsection{Grid}
\subsubsection{Initial conditions}
\subsubsection{Boundary conditions}
\subsubsection{Running the test}

\subsection{Internal waves} \label{sec:internalwaves}

\subsubsection{Grid}
\subsubsection{Initial conditions}
\subsubsection{Boundary conditions}
\subsubsection{Running the test}

\section{Parameter listing in suntans.dat} \label{sec:params}

\subsection{Physical/Computational parameters}

These parameters define values used in SUNTANS.  The syntax of the line in suntans.dat is given by
\begin{verbatim}
variablename  variablevalue   # Description of variable
\end{verbatim}
When this file is read, the effect is equivalent to \verb+variablename=variablevalue+.
This file cannot have empty lines, but the spacing between variablename and value is arbitrary, as long
as it does not contain a new line.  Only the first variable is read before the \verb+#+ sign.  That is, old variable values can exist to
the right of the variable values being used and they are neglected.  The following line is therefore legal:
\begin{verbatim}
dt    0.025  0.05 (unstable)  0.0125 (10/12/04)  # Time step size
\end{verbatim}
This will have the effect of \verb+dt=0.025+ and neglecting the rest of the line after \verb+0.025+.

\subsubsection{Nkmax: $N_{kmax}\ge 1$}

Number of cells in the vertical.  This is used when the -g flag is
specified in order to build the vertical grid levels.  It must be
greater than or equal to 1.  

\subsubsection{stairstep: Boolean}

If stairstep is 1 then the vertical grid spacing does not change in
the horizontal. If stairstep is 0, then partial-stepping is employed and
the height of the bottom cell
is set such that the bottom face of the cell coincides with the actual
value of the depth. Otherwise (when stairstep=1), the bottom face of
of the lowermost cell is always greater than the actual depth.  

\subsubsection{rstretch: $-1.1 < r < -1$ or $1 < r < +1.1$}

Employ vertical grid stretching such that the distribution of vertical
grid spacings is given by
\[
\Delta z_k = r\,\Delta z_{k+1}\,,
\]
where $0\le \mbox{k} < \mbox{Nkmax}$.  If $r<0$ then the grid is refined near the
bottom, otherwise it is refined at the free-surface.

\subsubsection{CorrectVoronoi: Boolean}

If CorrectVoronoi is 1 then degenerate triangles are corrected using
the VoronoiRatio parameter defined below.  For a given triangulation,
stability is dictated by the smallest distance between Voronoi
points.  The worst case occurs when two right triangles abut each
other, since they have coincident Voronoi points.  In SUNTANS, the
Voronoi points are corrected if they are too close to each other
relative to the distance between the centroids of the neighboring triangles.
If triangle $1$ and $2$ have centroids defined by $(xc_1,yc_1)$ and $(xc_2,yc_2)$
and Voronoi points defined by $(xv_1,yv_1)$ and $(xv_2,yv_2)$, then the distance
between the centroids is given by
\[
D_c^2 = (xc_2-xc_1)^2 + (yc_2-yc_1)^2\,,
\]
and the distance between the Voronoi points is given by
\[
D_v^2 = (xv_2-xv_1)^2 + (yv_2-yv_1)^2\,.
\]
The Voronoi points are corrected if $D_g/D_c< V_r$, and if this
is the case, they are updated with
\begin{eqnarray}
xv_1 &=& xc + V_r(xc_1-xc)\,,\nonumber\\
yv_1 &=& yc + V_r(yc_1-yc)\,,\nonumber\\
xv_2 &=& xc + V_r(xc_2-xc)\,,\nonumber\\
yv_2 &=& yc + V_r(yc_2-yc)\,,\nonumber
\end{eqnarray}
where $xc=(xc_1+xc_2)/2$ and $yc=(yc_1+yc_2)/2$.  Using this correction methodology,
setting $V_r=1$ moves the Voronoi points to the centroids of the cells.

\subsubsection{VoronoiRatio: $0\le V_r\le 1$}

Adjustment factor for degenerate triangles.  If $V_r=1$, then
all Voronoi points are moved to the centroids, while if $V_r=0$, 
then no correction is performed.  See CorrectVoronoi.

\subsubsection{vertgridcorrect: Boolean}

For an equispaced vertical grid, the vertical grid spacing is constant and
is given by $\Delta z=D_{max}/N_{kmax}$, where $D_{max}$ is the maximum depth in the domain.
In the rare case for which the minimum depth, $D_{min}$ in the domain is less than $\Delta z$, there
are not enough grid points to resolve the region with the smallest depth.  If this is the
case and vertgridcorrect
is set to 1, then the number of vertical grid cells is adjusted such that $\Delta z=D_{min}$,
such that $N_{kmax}=D_{max}/D_{min}$.

\subsubsection{IntDepth: Boolean}

If set to 1, then the depths at the Voronoi points are interpolated from the
depth specified by the depth file (see below).  Otherwise, the depths are
specified in the file \verb+initialization.c+.

\subsubsection{dzsmall: No longer used}

\subsubsection{scaledepth: Boolean}

For debugging purposes.  If set to 1, scales the depth by scaledepthfactor (see below).

\subsubsection{scaledepthfactor}

If scaledepth=1, this scales the depth by the given amount and hence
can be used to reduce the depth and hence the surface gravity wave speed by
a desired amount.

\subsubsection{thetaramptime: $\tau_\theta >0$}

This is used to damp out transient barotropic motions by initializing
the value of $\theta$ in the free-surface solver to 1 and ramping it
down to the value of $\theta$ specified below.  The $\tau_\theta$ parameter
determines the timescale over which this is damped, such that, if the value
of $\theta$ specified below is given by $\theta_0$, then the value of
$\theta$ that is used in the calculations is given by
\begin{eqnarray}
\theta(t) &=& \theta_0 + (1-\theta_0)\exp\left(-\frac{t}{\tau_\theta}\right)\nonumber\,.
\end{eqnarray}

\subsubsection{beta: $\beta\ge 0$}

Expansivity of salt.  This is used in the gravity term on the right hand side of
the Navier-Stokes equations in the form
\[
-g\beta\left(s-s_0\right)\,,
\]
where $s(x,y,z,t)$ is the salinity and $s_0(z)$ is the initial salinity.  If $\beta=0$
advection of salinity is not computed.  


\subsubsection{theta: $0<\theta\le 1$}

Implicitness parameter for the free-surface solver and the vertial diffusion terms.
\begin{itemize}
\item $\theta=0$: Fully explicit (unstable)
\item $\theta=0.5$: Crank-Nicolson (neutrally stable in the linear sense)
\item $\theta=1.0$: Fully implicit
\item $\theta=0.55$: For practical simulations
\end{itemize}

\subsubsection{thetaS: $0\le \theta_S \le 1$}

Implicitness parameter for vertical scalar advection and diffusion.  Note that this
value of thetaS does not necessarily share the same stability properties as the
free-surface solver since stability for scalar transport is governed by
the horizontal Courant number even when $\theta_S>0.5$.
\begin{itemize}
\item $\theta_S=0$: Fully explicit 
\item $\theta_S=0.5$: Crank-Nicolson (Ensures no vertical Courant limitation for advection or diffusion)
\item $\theta_S=1.0$: Fully implicit (same as above but first-order accurate)
\item $\theta_S=\theta$: To guarantee consistency with continuity 
\end{itemize}

\subsubsection{thetaB: Not used}

\subsubsection{kappa\_s: $\kappa_s\ge 0$}

Laminar vertical diffusivity of salt in units of m$^2$ s$^{-1}$.  Does not affect stability.

\subsubsection{kappa\_sH: $\kappa_{sH}\ge 0$}

Laminar horizontal diffusivity of salt in units of m$^2$ s$^{-1}$.  For stability 
\[
\frac{\kappa_{sH}\Delta t}{\mbox{min}(D_g^2)}<\frac{1}{2}\,,
\]
where $D_g$ is the distance between Voronoi points.  

\subsubsection{gamma: $\gamma$: Boolean}

Temperature is implemented as a passive scalar.  If gamma is set to 0 then scalar
transport of T is not computed.

\subsubsection{kappa\_T: $\kappa_T\ge 0$}

Same as $kappa\_s$ but for T.

\subsubsection{kappa\_TH: $\nu_{TH}\ge 0$}

Same as $kappa\_TH$ but for T.

\subsubsection{nu: $\nu\ge 0$}

Laminar vertical diffusivity of momentum in units of m$^2$ s$^{-1}$.  Does not affect stability.

\subsubsection{nu\_H: $\nu_{H}\ge 0$}

Laminar horizontal diffusivity of momentum in units of m$^2$ s$^{-1}$.  For stability 
\[
\frac{\nu_{H}}{\Delta t}{\mbox{min}(D_g^2)}<\frac{1}{2}\,,
\]
where $D_g$ is the distance between Voronoi points.  

\subsubsection{tau\_T: $\tau_T$}

Parameter used in boundaries.c to employ a surface wind stress in units of m$^2$ s$^{-2}$.
See Section \ref{sec:boundary}

\subsubsection{z0T: $z_{0T}$}

Lid roughness used to calculate drag at the lid.  See CdT.

\subsubsection{z0B: $z_{0B}$}

Bottom roughness used to calculate drag at the bottom boundary layer.  See CdB.

\subsubsection{CdT: $C_{dT}$}

If the roughness at the lid is zero (i.e. z0T=0) then the drag coefficient at the lid is given by
this constant, otherwise the drag coefficient is calculated with the rough wall 
relationship
\[
C_{dT} = \left[\ln\left(\frac{1}{2}\frac{\Delta z_{top}}{z_{0T}}\right)\right]^{-2}\,.
\]
where $\Delta z_{top}$ is the thickness of the top cell.

\subsubsection{CdB: $C_{dB}$}

If the roughness at the bottom is zero (i.e. $z_{0B}$=0) then the drag coefficient at the bottom is given by
this constant, otherwise the drag coefficient is calculated with the rough wall
relationship
\[
C_{dB} = \left[\ln\left(\frac{1}{2}\frac{\Delta z_{bot}}{z_{0B}}\right)\right]^{-2}\,,
\]
where $\Delta z_{bot}$ is the thickness of the bottom cell.

\subsubsection{CdW: $C_{dW}$}

Constant drag coefficient of sidewalls.  Drag on sidewalls is only computed if the wall
does not extend up to the free surface.  For example, in a compound channel, sidewall
drag is only computed within the channel and not on the edges of the floodplain, as shown
in Figure \ref{fig:compoundchannel}.
\insertfig{0.8}{figures/compoundchannel}{Example of a compound channel, for which sidewall
drag is only computed in the channel and not on the shoals.}{fig:compoundchannel}

\subsubsection{turbmodel: Boolean}

If turbmodel is 1 then the Mellor-Yamada level 2.5 turbulence model is used, otherwise
no turbulence model is employed.  

\subsubsection{dt: $\Delta t$}

Time step. Assuming $\theta>0.5$, stability is limited by
\[
\Delta t < C\left[\frac{\min(D_g)}{\max(|U|)},\frac{\min(\Delta z)}{\max(|w|)},
\frac{\min(D_g)}{\max(c_i)},
\frac{1}{2}\frac{\min(D_g)^2}{\max(\kappa_{sH})},
\frac{1}{2}\frac{\min(D_g)^2}{\max(\kappa_{TH})},
\frac{1}{2}\frac{\min(D_g)^2}{\max(\nu_{H})}
\right]\,,
\]
where $c_i$ is the internal wave speed, $C$ is the relevant Courant number, and $D_g$
is the minimum Voronoi distance.

\subsubsection{Cmax: $C_{max}>0$}

Maximum permissible Courant number for advection of momentum.  

\subsubsection{nsteps: $N_{steps}\ge 0$}

Total number of time steps. 


\subsubsection{ntout: $N_{tout}> 0$}

How often to output data.  Since the first time step is always output, 
the total number of time steps that are output is then given
by
\[
1+\mbox{floor}\left(\frac{N_{steps}}{N_{tout}}\right)\,.
\]


\subsubsection{ntprog: $0\le N_{tprog}\le 100$}

Report progress at $N_{tprog}$\% intervals if $N_{tprog}>0$, otherwise do not report
progress.  Either way, progress is reported only if the verbose flag is at least \verb+-v+.

\subsubsection{ntconserve: $0\le N_{tconserve}\le N_{steps}$}

How often to output conservative data, such as mass, volume, and potential energy, into
the file specified by ConserveFile.  Output should be edited to suit user's needs in
the \verb+OutputData+ function in \verb+phys.c+.

\subsubsection{nonhydrostatic: Boolean}

(1): Compute the nonhydrostatic pressure, (0): neglect the nonhydrostatic pressure and
calculate the vertical velocity with continuity.

\subsubsection{cgsolver: No longer used}

\subsubsection{maxiters: $I_{max,H}>0$}

Maximum number of iterations allowed of the free-surface conjugate-gradient solver before
reporting nonconvergence.  If the free-surface solver is not converging in less than 200
iterations then the problem is poorly conditioned.

\subsubsection{qmaxiters: $I_{max,Q}>0$}

Maximum number of iterations allowed of the nonhydrostatic pressure conjugate-gradient solver before
reporting nonconvergence. 

\subsubsection{qprecond: 0,1, or 2}

Type of preconditioner to use for the nonhydrostatic pressure solver.  For a typical environmental
flow with an aspect ratio of $\order{10^2}$:
\begin{enumerate}
\item[0] No preconditioner - 1000s of iterations to converge
\item[1] Diagonal preconditioner - 100s of iterations to converge
\item[2] Block-diagonal preconditioner - 10s of iterations to converge.
\end{enumerate}
There is no significant difference among the preconditioners when the aspect ratio is roughly 1.

\subsubsection{epsilon: $\epsilon_H>0$}

Tolerance for free-surface conjugate gradient solver.  Default: $\epsilon_H=10^{-10}$.

\subsubsection{qepsilon: $\epsilon_Q>0$}

Tolerance for nonhydrostatic pressure conjugate gradient solver.  Default: $\epsilon_Q=10^{-5}$.

\subsubsection{resnorm: Boolean}

Whether or not to normalize the residual when computing tolerance criteria for the conjugate
gradient solvers.  At a given iteration, if the residual is given by $r=b-Ax$, then tolerance is evaluated with:
\begin{enumerate}
\item[0]: error=$r^T r$
\item[1]: error=$\frac{r^T r}{b^T b}$
\end{enumerate}

\subsubsection{relax: No longer used}

\subsubsection{amp}

Amplitude parameter for use in \verb+boundaries.c+ in the form \verb+prop->amp+.

\subsubsection{omega}

Frequency parameter for use in \verb+boundaries.c+ in the form \verb+prop->omega+.

\subsubsection{flux}

Flux parameter for use in \verb+boundaries.c+ in the form \verb+prop->flux+.

\subsubsection{timescale}

Timescale parameter for use in \verb+boundaries.c+ in the form \verb+prop->timescale+.

\subsubsection{volcheck: Boolean}

(0): Do not check for volume conservation, (1): check for volume conservation and print out errors
if volume is not conserved to within the tolerance defined by \verb+CONSERVED+ in \verb+suntans.h+.
Prints regardless of verbosity setting at command line.

\subsubsection{masscheck: Boolean}

(0): Do not check for mass conservation, (1): check for mass conservation and print out errors
if volume is not conserved to within the tolerance defined by \verb+CONSERVED+ in \verb+suntans.h+.
Prints regardless of verbosity setting at command line.

\subsubsection{nonlinear: 0,1, or 2}

Advection scheme for momentum:
\begin{enumerate}
\item[0]: No advection of momentum, i.e. $\ub\cdot\nabla\ub=0$.
\item[1]: First-order upwind for momentum.
\item[2]: Second-order central for momentum.  Note that diffusion must be present for stability.  While
it is difficult to perform an exact stability analysis for the unstructured-grid equations, the 1-d
stability limitation requires that 
grid Peclet number according to 
\[
Pe_\Delta<\frac{2}{C}\,,
\]
where $Pe_\Delta = \frac{\max(|U|)\max(D_g)}{\min(\kappa_H)}$ and $C=\frac{\max(|U|)\Delta t}{\max(D_g)}$,
which translates into the requirement that the horizontal diffusion be restricted to
\[
\kappa_H>\frac{\max(|U|)^2\Delta t}{2}\,.
\]

\end{enumerate}

\subsubsection{newcells: Boolean}

Since the advection of momentum is not conservative in the upper cells, the velocity in the upper cells
can be adjusted to ensure that
\[
U_{top}^{n+1}\Delta z_{top}^{n+1} = 
U_{top}^{n}\Delta z_{top}^{n}\,.
\]
This should be used with caution and results should be checked to make sure this does not alter them
significantly.  Otherwise the upper layer depth is too small relative ot the free surface motions.\\
(0): Do not adjust upper layer cells, (1): Adjust upper layer cells.

\subsubsection{wetdry: Boolean}

Different time-stepping schemes are used for horizontal scalar advection when wetting and drying occur (vertical
advection always uses the $\theta$ method).  To guarantee consistency
with continuity, the $\theta$ method must be used for scalar advection.  This is formally first-order
accurate in time, so results are more accurate when second-order Adams-Bashforth is used if there
is no wetting and drying.  Therefore, the wetdry Boolean is set according to:\\
(0): No wetting and drying, employ AB2 for horizontal scalar advection\\
(1): Wetting and drying: employ $\theta$-method for horizontal scalar advection.

\subsubsection{Coriolis\_f: $f\ge 0$}

Coriolis frequency $f=2\Omega\sin(\phi)$, where $\phi$ is the latitude.

\subsubsection{sponge\_distance: $D_{sponge}\ge 0$}

An example of how to implement a sponge layer is shown in \verb+phys.c+ in the form
\[
\frac{u^{n+1}-u^n}{\Delta t} = -\frac{1}{\tau_{sponge}}\exp\left(-\frac{x}{D_{sponge}}\right)\,,
\]
where the $\tau_{sponge}$ timescale is defined by the value of sponge\_decay.  If $D_{sponge}=0$ then
no sponge layer is employed.  {\bf Note that this sponge layer assumes the boundary is located at $x=0$
and that the sponge layer is roughly $D_{sponge}$ m thick and extends in the positive $x$ direction!}

\subsubsection{sponge\_decay: $\tau_{sponge}>0$}

Decay timescale for sponge layer.

\subsubsection{readSalinity: Boolean}

(0): Vertical salinity distribution is specified in \verb+initilization.c+\\
(1): Read vertical salinity distribution from the file specified by the InitSalinityFile parameter.
This file must be in binary form and must contain $N_{kmax}$ double precision values in top-to-bottom
order.

\subsubsection{readTemperature: Boolean}

(0): Vertical temperature distribution is specified in \verb+initilization.c+\\
(1): Read vertical temperature distribution from the file specified by the InitTemperatureFile parameter.
This file must be in binary form and must contain $N_{kmax}$ double precision values in top-to-bottom
order.

\subsection{Input/Output files}

These parameters define the names of the input files.  The syntax of the line in suntans.dat is given by
\begin{verbatim}
filespecifier  fileprefix   # Description of parameter
\end{verbatim}
Global files do not contain the processor suffix, while per-processor files contain the processor
number as the suffix.
For example, in a four-processor run, there will be four i/o files relating
to this specifier, i.e. fileprefix.0, fileprefix.1, fileprefix.2, and fileprefix.3.  The file
called fileprefix (with no suffix) contains information for all processors.  

\subsubsection{pslg: input}

Planar straight line graph file. Does not contain the processor number suffix.
 See Section \ref{sec:grids} for details.

\subsubsection{points: input/output}

Delaunay points file ($N_p$ total points).  Does not contain
the processor number suffix. For details see Section \ref{sec:grids}.
\begin{list}{}
\item Size: $N_p\times 3$
\item Type: ASCII
\item Format: (float)xp, (float)yp, (int)marker
\end{list}

\subsubsection{edges: input/output}

Edge connectivity file ($N_e$ total edges). For details see Section \ref{sec:grids}.
\begin{list}{}
\item Size: $N_e\times 5$
\item Type: ASCII
\item Format: 
\begin{list}{}
\item (int$\times$ 2)Indices to Delaunay points that make up endpoints
\item (int)Edge marker for boundary condition
\item (int$\times$ 2)Indices to Voronoi points on either side of edge
\end{list}
\end{list}


\subsubsection{cells: input/output}

Cell connectivity file ($N_c$ total cells). For details see Section \ref{sec:grids}.
\begin{list}{}
\item Size: $N_c\times 8$
\item Type: ASCII
\item Format: 
\begin{list}{}
\item (float$\times$ 2) Voronoi coordinates
\item (int $\times$ 3) Indices to points that make up vertics
\item (int $\times$ 3) Indices to neighboring cells 
\end{list}
\end{list}

\subsubsection{depth: input}

Contains bathymetry data used to interpolate the depth onto the Voronoi points only
if the IntDepth parameter is set to 1.  Otherwise the depth is set in initialization.c.
The spacing of the data is arbitrary since the interpolation routine searches for the
nearest neighbors to perform the interpolations.
\begin{list}{}
\item Size: $\mbox{Number of bathymetry data points}\times 3$
\item Type: ASCII
\item Format: 
\begin{itemize}{}
\item (float)x
\item (float)y
\item (float)depth
\end{itemize}
\end{list}

\subsubsection{celldata: input/output}

Contains cell-centered data for each processor. ($N_c$ total cells)
\begin{list}{}
\item Size: $N_c\times 17$
\item Type: ASCII
\item Format:
\begin{list}{}
\item (float)Voronoi point x
\item (float)Voronoi point y
\item (float)Cell Area
\item (float)Voronoi depth
\item (int)Number of vertical levels
\item (3$\times$int)Index to edge faces
\item (3$\times$int)Index to cell neighbors
\item (3$\times$int)Dot-product with outward normal on faces
\item (3$\times$float)Distance from Voronoi point to normal on faces
\end{list}
\end{list}

\subsubsection{edgedata: input/output}

Contains edge-centered data for each processor. ($N_e$ total edges)
\begin{list}{}
\item Size: $N_e\times 13$
\item Type: ASCII
\item Format:
\begin{list}{}
\item (float)Edge length
\item (float)Voronoi length 
\item (float$\times$ 2)x-y components of unique normal
\item (float$\times$ 2)x-y coordinates of center of edge
\item (int)Number of edges in vertical
\item (int)Maximum number of neighboring cells in vertical
\item (int)Upwind cell neighbor (if $U>0$)
\item (int)Downwind cell neighbor (if $U>0$)
\item (int$\times$ 2) gradf pointers (see Section \ref{sec:grids})
\item (int)Edge marker
\end{list}
\end{list}

\subsubsection{vertspace: input/output}

Contains vertical grid spacing in top-to-bottom ordering.  Same for all processors.
\begin{list}{}
\item Size: $N_{kmax}\times 1$
\item Type: ASCII
\item Format: (float)Grid spacing
\end{list}

\subsubsection{topology: input/output}

Contains topology information per processor. ($N_c$ = number of cells, $N_e$ = number of edges)
\begin{list}{}
\item Size: Depends on processor topology
\item Type: ASCII
\item Format:
\begin{list}{}
\item (int)Number of processors
\item (int)Number of neighboring processors (Numneighs)
\item (int$\times$Numneighs)Processor neighbor list
\item For each neighboring processor:
\begin{list}{}
\item (int)Number of cells to send (cellsend)
\item (int)Number of cells to receive (cellrecv)
\item (int)Number of edges to send (edgesend)
\item (int)Number of edges to receive (edgerecv)
\item (int$\times$ cellsend)Indices of cells to send
\item (int$\times$ cellrecv)Indices of cells to recv
\item (int$\times$ edgesend)Indices of edges to send
\item (int$\times$ edgerecv)Indices of edges to recv
\end{list}
\item (int$\times$3)Indices for celldist array
\item (int$\times$6)Indices for edgedist array
\item (int$\times N_c$)Indices for cellp array
\item (int$\times N_e$)Indices for edgep array
\end{list}
\end{list}

\subsubsection{FreeSurfaceFile: output}

Contains the free-surface data. ($N_c$ = number of cells)
\begin{list}{}
\item Size: $\left[1+\mbox{floor}\left(\frac{N_{steps}}{N_{tout}}\right)\right]\times N_c$
\item Type: binary
\item Format: (double$\times N_c$) for each time step.  
\item Matlab equivalent: h(1:Nc) for each time step.
\end{list}

\subsubsection{HorizontalVelocityFile: output}

Contains the three components of velocity at the Voronoi points. ($N_c$ = number of cells)
\begin{list}{}
\item Size: $\left[1+\mbox{floor}\left(\frac{N_{steps}}{N_{tout}}\right)\right]\times N_{kmax} \times 3 \times N_c$
\item Type: binary
\item Format: (double$\times N_{kmax} \times 3 \times N_c$) for each time step.  
\item Matlab equivalent: u(1:Nkmax,1:3,1:Nc) for each time step.
\end{list}

\bigskip
\noindent
Note: empty cells (beneath z=-d) contain value of \verb+EMPTY+ defined in \verb+suntans.h+.


\subsubsection{VerticalVelocityFile: output}

Contains the vertical velocity at the horizontal faces. ($N_c$ = number of cells)
\begin{list}{}
\item Size: $\left[1+\mbox{floor}\left(\frac{N_{steps}}{N_{tout}}\right)\right]\times (1+N_{kmax}) \times N_c$
\item Type: binary
\item Format: (double$\times (1+N_{kmax})\times N_c$) for each time step.  
\item Matlab equivalent: w(1:Nkmax+1,1:Nc) for each time step.  
\end{list}

\bigskip
\noindent
Note: empty cells (beneath z=-d) contain value of \verb+EMPTY+ defined in \verb+suntans.h+.

\subsubsection{SalinityFile,BGSAlinityFile,TemperatureFile,\\PressureFile,VerticalGridFile,EddyViscosityFile,\\ScalarDiffusivityFile: outputs}

Contain data at Voronoi points for the given quantity. ($N_c$ = number of cells)
\begin{list}{}
\item Size: $\left[1+\mbox{floor}\left(\frac{N_{steps}}{N_{tout}}\right)\right]\times N_{kmax} \times N_c$
\item Type: binary
\item Format: (double$\times N_{kmax}\times N_c$) for each time step.  
\item Matlab equivalent: s(1:Nkmax,1:Nc) for each time step.  
\end{list}

\bigskip
\noindent
Note: empty cells (beneath z=-d) contain value of \verb+EMPTY+ defined in \verb+suntans.h+.

\subsubsection{ConserveFile: output}

File used to report conservative variables such as volume, mass, and energy.  The format for this file
is user-implemented in the \verb+OutputData+ function in \verb+phys.c+.

\subsubsection{ProgressFile: output}

Short file containing a printout of the run progress in the form
\begin{verbatim}
On (int) of (int),t=(float) ((int)% Complete, (int) output)
\end{verbatim}
to show total number of time steps complete, the current simulation time (t=...), 
the percentage completion, and the number of steps that have been output for
viewing.

\subsubsection{StoreFile: output}

Saves data to be loaded for a restart run or to analyze data in existence at the time of
a blow up.    
\begin{list}{}
\item Size: Depends on grid geometry since cells beneath the depth are not stored (unlike other
individual data files).
\item Type: binary
\item Format: 
\begin{list}{}
\item (int)last time step
\item (double$\times N_c$)Free surface
\item (double$\times N_e \times N_{ke}$)AB2 term at n-1 for horizontal momentum 
\item (double$\times N_c \times N_{k}$)AB2 term at n-1 for vertical momentum 
\item (double$\times N_c \times N_{k}$)AB2 term at n-1 for salinity
\item (double$\times N_c \times N_{k}$)AB2 term at n-1 for temperature
\item (double$\times N_c \times N_{k}$)AB2 term at n-1 for Mellory-Yamada 2.5 q when turbulence=1
\item (double$\times N_c \times N_{k}$)AB2 term at n-1 for Mellory-Yamada 2.5 L  when turbulence=1
\item (double$\times N_c \times N_{k}$)Mellor-Yamada 2.5 q  when turbulence=1
\item (double$\times N_c \times N_{k}$)Mellor-Yamada 2.5 L  when turbulence=1
\item (double$\times N_c \times N_{k}$)Turbulent eddy-viscosity
\item (double$\times N_c \times N_{k}$)Turbulent scalar-diffusivity
\item (double$\times N_e \times N_{ke}$)Horizontal velocity
\item (double$\times N_c \times (N_{k}+1)$)Vertical velocity
\item (double$\times N_c \times N_{k}$)Nonhydrostatic pressure 
\item (double$\times N_c \times N_{k}$)Salinity
\item (double$\times N_c \times N_{k}$)Temperature
\item (double$\times N_c \times N_{k}$)Background salinity 
\end{list}
\end{list}

\subsubsection{StartFile: input}

Used to read in data for a restart run.  See Section \ref{sec:restart} for details.


\subsubsection{InitSalinityFile: input}

Contains initial vertical top-to-bottom salinity distribution.  Read only when readSalinity=1.
\begin{list}{}
\item Size: $N_{kmax}$
\item Type: binary
\item Format: (double$\times N_{kmax}$)
\end{list}


\subsubsection{InitTemperatureFile: input}

Contains initial vertical top-to-bottom temperature distribution.  Read only when \\readTemperature=1.
\begin{list}{}
\item Size: $N_{kmax}$
\item Type: binary
\item Format: (double$\times N_{kmax}$)
\end{list}

\bibliographystyle{plain}
\bibliography{bibliography}

\end{document}
