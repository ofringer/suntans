%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% SUNTANS user guide.
%
% Oliver Fringer
% Stanford University
% 10 June 2004
%
% $Id: user_guide.tex,v 1.4 2004-06-24 08:37:27 fringer Exp $
% $Log: not supported by cvs2svn $
% Revision 1.3  2004/06/23 06:18:25  fringer
% Added CVS section for anonymous updating (read-only).
%
% Revision 1.2  2004/06/14 07:51:30  fringer
% Added to section on reading grids from file.
%
% Revision 1.1  2004/06/14 05:43:58  fringer
% Suntans user guide added to CVS repository.
%
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\documentclass[12pt,oneside]{article}
%\usepackage{amsfonts,graphics,/usr/share/texmf/tex/latex/misc/authordate1-4}
\usepackage{amsfonts,graphics}

\newif\ifpdf\ifx\pdfoutput\undefined\pdffalse\else\pdfoutput=1\pdftrue\fi
\newcommand{\pdfgraphics}{\ifpdf\DeclareGraphicsExtensions{.pdf,.jpg}\else\fi}

\textheight 9.0in
\textwidth 6.5in
\oddsidemargin 0.0in

\include{newcommands}

\begin{document}
\pdfgraphics

\title{Suntans User Guide\\
{\large Stanford Unstructured Nonhydrostatic 
Terrain-following Adaptive Navier-Stokes Simulator}}
\author{O. B. Fringer\\
\small
Environmental Fluid Mechanics Laboratory,  \\
Stanford University\\
Stanford, CA 94305-4020
\normalsize}
\date{\today}

\maketitle

\tableofcontents

\section{Downloading and installing Suntans}

In order to use Suntans, you must also install the message-passing
interface (MPI), the parallel graph partitioning libraries (ParMetis~\cite{PARMETIS[1998]}),
the grid generation package Triangle~\cite{TRIANGLE[1996]}.  Instructions for 
downloading and installing these packages are available from the individual websites
for each package:
\begin{tabbing}
MPI\hspace{0.5in}\=  \verb+http://www-unix.mcs.anl.gov/mpi/mpich/+\\
ParMetis \> \verb+http://www-users.cs.umn.edu/~karypis/metis/parmetis/+\\
Triangle \> \verb+http://www-2.cs.cmu.edu/~quake/triangle.html+
\end{tabbing}
Note that you must compile the triangle libraries as object files by making them
with \verb+make trilibrary+.

\subsection{Downloading and installing the latest source}

To obtain a copy of Suntans, download the latest version from the suntans
web page at \verb+http://suntans.stanford.edu/downloads+.  Follow the following
steps to install the software.  {\bf Note: Do not continue beyond this point unless
you have installed the required packages mentioned in the previous paragraph!
Suntans will not compile unless you do so, even if you do not intend to run it in
parallel.}
\begin{enumerate}
\item First unpack the gzipped tar archive with
\begin{verbatim}
tar xzvf suntans-X.X.tgz
\end{verbatim}
where \verb+X.X+ is the latest version of Suntans.  
\item In the suntans-X.X directory, edit the Makefile so that the directories containing the appropriate packages
are correctly specified as follows:
\begin{itemize}
\item \verb+MPIHOME+ should contain the base directory of the mpich distribution.
For example, 
\verb+MPIHOME=/usr/local/mpich-1.2.5.2+
\item \verb+SUNTANSHOME+ should contain the location of this distribution of Suntans.
\item \verb+PARMETISHOME+ should contain the base directory of the ParMetis distribution.
\item \verb+TRIANGLEHOME+ should contain the base directory of the Triangle libraries.
\item \verb+BACKUP+ should point to a directory in which you would like to store backup
copies of the Suntans distribution.
\end{itemize}
\item Once these locations are properly specified, compile the Suntans executable with
\begin{verbatim}
make
\end{verbatim}
This will create the main executable \verb+sun+.
\item Compile the Suntans graphical user interface with
\begin{verbatim}
make sunplot
\end{verbatim}
This will create the gui executable \verb+sunplot+.  Note:  This GUI requires the
existence of the \verb+Xlib+ libraries and it is assumed that these are located
in \verb+/usr/X11R6+.  Make sure the \verb+XINC+ and \verb+XLIBDIR+ variables
are specified correctly in the \verb+Makefile+ if \verb+sunplot+ does not compile.
\item In order to remove the object files, use
\begin{verbatim}
make clean
\end{verbatim}
\item To clean up the directory even further (remove \verb+*~, #*#, PI*, sun, sunplot+),
use
\begin{verbatim}
make superclean
\end{verbatim}
\end{enumerate}

\subsection{Keeping up to date with CVS}

You can keep an up to date copy of the suntans distribution on your machine by using the
cvs repository.  To do so, you need to send your ssh public key to the suntans server administrator so that
it can be installed in the authorized keys file on the suntans server.  To obtain your
public key, use
\begin{verbatim}
ssh-keygen -t rsa
\end{verbatim}
This will create a public key in the file \verb+~/.ssh/id_rsa.pub+, which you should send
via email to the administrator.  You may use an empty passphrase but it is not recommended.
Once you send your public key to the suntans cvs administrator, in the \verb+bash+ shell, type
\begin{verbatim}
export CVSROOT=:ext:cvsuser@suntans:/home/cvs
export CVS_RSH=ssh
\end{verbatim}
This sets the \verb+CVSROOT+ environmental variable so that when you use the cvs commands
they look for the cvs repository on the suntans server as user cvsuser.
You will be granted read-only access to the cvs repository, so you can keep an up-to-date
copy of the latest source on your machine.  To check out the latest copy, type
\begin{verbatim}
cvs checkout suntans
\end{verbatim}
This will create the \verb+suntans+ directory and all of the subdirectories on the server.
If you would like to sync your copy of suntans with the copy on the server, use
\begin{verbatim}
cvs update suntans
\end{verbatim}
Note that you are only allowed read access to the cvs server.  Any changes you make to
the suntans files on your machine will not be updated on the server unless you are added
to the group list on the server.  You will also not be able to ssh into the server if you
try, as this will freeze your screen as only cvs access is allowed via ssh.

\section{Running Suntans}

To execute a single processor job, suntans is executed by running the main executable \verb+sun+ with
\begin{verbatim}
mpirun sun -t -g -s 
\end{verbatim}
This assumes that the input and output data required to run Suntans is in the same directory
as the executable \verb+sun+.  This is in general not a good idea because Suntans creates a host
of input and output files that will clutter up the local directory.  It is best to create a new
directory and specify that directory as the working data directory on the command line.  For
example, if the working directory is in the local \verb+data+ directory, then Suntans would be
run with
\begin{verbatim}
mpirun sun -t -g -s --datadir=./data
\end{verbatim}
To run Suntans on multiple processors, use the \verb+-np+ flag with \verb+mpirun+. For example,
to run Suntans on 64 processors, use
\begin{verbatim}
mpirun -np 64 sun -t -g -s --datadir=./data
\end{verbatim}
The following is a list of flags that determine the behavior of the \verb+sun+ executable upon
running:
\begin{itemize}
\item{\verb+-t+} Create a triangulation from a planar straight line graph.  For details see
Section \ref{sec:grids}.
\item{\verb+-g+} Partition the triangulation among the given number of processors and
compute grid geometry and cell and processor connectivity.  For details see Section \ref{sec:grids}.
\item{\verb+-s+} Run the Suntans solver.
\item{\verb+-v[vvv]+} Output information about the progress of the run.  The more \verb+v+s, the
more verbose the output (maximum 4).
\item{\verb+-w+} Print out warnings that may lead to crashes or erroneous results to the screen
(independent of \verb+-v+).
\item{\verb+-r+} Restart Suntans from a previous run.  For details see Section \ref{sec:restart}.
\end{itemize}
A typical Suntans run with, for example, 4 processors, will proceed as follows:
\begin{enumerate}
\item Create the triangulation and grid information and place it into the \verb+data+ directory
with
\begin{verbatim}
mpirun -np 4 sun -t -g --datadir=./data
\end{verbatim}
This stores the grid information in files (see Section \ref{sec:grids}) for later reading later.
Since this process may take some time it is a good idea to run this once for large grids and
read in the grid data from a file.  
\item Read the grid data from the files and run the solver and output information about the
run with
\begin{verbatim}
mpirun -np 4 sun -s -vv --datadir=./data
\end{verbatim}
\item Once this run is finished it is possible to restart the run (for details see Section \ref{sec:restart})
with the data in \verb+data+ using
\begin{verbatim}
mpirun -np 4 sun -s -r -vv --datadir=./data
\end{verbatim}
\end{enumerate}

Note that the reason behind being able to specify the data directory at the command line is that
it enables the executable to be run from the same directory but to use data from different directories
that may contain different parameters.  For example, if the \verb+data1+ directory and \verb+data2+ 
directory contain different grid data (from previous calls to Suntans with the \verb+-t+ and \verb+-g+ flags),
then Suntans can be run either with
\begin{verbatim}
mpirun -np 4 sun -s --datadir=./data1
\end{verbatim}
or with
\begin{verbatim}
mpirun -np 4 sun -s --datadir=./data2
\end{verbatim}

\section{The main Suntans input file} \label{sec:suntans.dat}

The main Suntans input file is called \verb+suntans.dat+  and contains three
columns.  The first column contains the name of the variable used in
the program while the second column contains its value, and the information
after that value is ignored.  Lines beginning
with \verb #  are ignored, while {\bf empty lines will cause the program to 
crash}.  The Suntans executable looks for this file in the directory specified
by \verb+--datadir=+.  If this is not specified, then it looks for it in the
same directory as the \verb+sun+ executable.
A listing of the parameters in the \verb+suntans.dat+ file is given in
Appendix \ref{app:params}.

\section{Creating or Reading in Triangular Grids} \label{sec:grids}

\subsection{Using the triangle libraries} \label{sec:tri}

Triangular grids can be created from a simple planar straight line
graph which is specified as the \verb+pslg+ file in \verb+suntans.dat+.
The format of this file is similar to the format of the planar straight
line graph file for use in triangle.  The planar straight line graph
file is a listing of points and edges which make up a closed contour.
These edges will comprise the boundaries of the triangulation that are
created by the triangle libraries.  The simplest PSLG file is one which
specifies a box with sides of length 1.  This requires four points and
four edges, as shown in the following file \verb+box.dat+:
\begin{verbatim}
# Number of points
4
# List of points (x,y,marker)
0.0 0.0 0
0.0 1.0 1
1.0 1.0 2
1.0 0.0 3
# Number of segments
4
# List of segments and boundary markers (point #, point #, marker)
0 1 1
1 2 1
2 3 1
3 0 1
# Number of holes
0
# Minimum area
.005
\end{verbatim}
The minimum area causes the triangle program to continue to add triangles
until the minimum area of one of the triangles satisfies this area.  
Setting the \verb+pslg+ variable to \verb+box.dat+ in \verb+suntans.dat+
and running Suntans with
\begin{verbatim}
mpirun sun -t -g --datadir=./data
\end{verbatim}
This creates a triangulation composed of 256 right triangles within a square
with sides of length 1.  The three columns after the number of points
specification correspond to the x,y coordinates of each point, along
with a marker for each point.  Following the number of segments specification,
the first two columns specify the indices of the points that make up
the end points of each segment in C-style numbering, such that the indices
go from 0 to one less than the number of points.  The third column in the
segment list specifies the marker for each segment.  This is how the boundary
conditions are specified, and is discussed in more detail in Section \ref{sec:boundary}.
The number of holes is currently not used.

Degenerate triangulations may arise when neighboring triangles are close to having
right angles.  In this case the distance between the Voronoi points may be close
to zero and hence may severely limit the time step.  This is remedied by setting
the \verb+CorrectVoronoi+ variable to 1 in \verb+suntans.dat+.  If this
parameter is set, then the Voronoi points are corrected when the distance
between Voronoi points is less than \verb+VoronoiRatio+ times the distance between
the cell centroids.  For example, for two neighboring right triangles, the Voronoi
points will be coincident and hence the distance between the Voronoi points of these
neighboring triangles will be zero.  If \verb+VoronoiRatio+ is set to \verb+0.5+, 
then the Voronoi points are adjusted so that the distance between them is half the
distance between the cell centroids.  If \verb+VoronoiRatio+ is set to \verb+1+,
then the Voronoi points correspond to the cell centroids.

\subsection{Reading Triangular Grids from a File} \label{sec:readgrid}

Use of the \verb+-t+ flag creates three files specified in \verb+suntans.dat+: 
\verb+points+, \verb+cells+, and \verb+edges+.  By default, these are specified
to be
\begin{verbatim}
points    points.dat
edges     edges.dat
cells     cells.dat
\end{verbatim}
The \verb+points+ file contains a listing of the x-y coordinates of the Delaunay points
in the full triangulation before being subdivided among different processors. 
This file contains three columns although the last column is never used.  The
total number of lines in this file is $N_p$, the number of triangle vertics in the triangulation.
The \verb+edges+ file contains $N_e$ rows each of which defines an
edge in the triangulation, and five columns in the following format:
\begin{verbatim}
Point1 Point2 Marker Voronoi1 Voronoi2
\end{verbatim}
\verb+Point1+ and \verb+Point2+ contain indices to points in the \verb+points+ file
and make up the end points of the Delaunay edges.  Because Suntans uses C-style
indexing, then $0\le$\verb+Point1,Point2+$<N_p$.  \verb+Marker+ specifies the type
of edge.  If \verb+Marker=0+, then it is a computational edge, otherwise, it is
a boundary edge, and the boundary condition is specified in Section \ref{sec:boundary}.
The last two entries, \verb+Voronoi1+ and \verb+Voronoi2+, are the indices to the Voronoi
points which make up the end points of the Voronoi edge which intersects this Delaunay edge.
As such, we must have $0\le$\verb+Voronoi1,Voronoi2+$<N_c$.
These Voronoi points correspond to triangles defined in the file \verb+cells+.  Voronoi points
which are ghost points are indicated by a $-1$.
The \verb+cells+ file contains $N_c$ rows each of which corresponds to a
triangle in the triangulation, and 8 columns in the following format:
\begin{verbatim}
xv yv Point1 Point2 Point3 Neigh1 Neigh2 Neigh3
\end{verbatim}
The \verb+xv+ and \verb+yv+ points correspond to the x-y coordinates
of the Voronoi points of each triangle and \verb+Point1+, \verb+Point2+, and \verb+Point3+
correspond to indices to points in the \verb+points+ file which make up the
vertices of the triangle.  These indices must satisfy \\
$0\le$\verb+Point1,Point2,Point3+$<N_p$. \\
\verb+Neigh1+, \verb+Neigh2+, and
\verb+Neigh3+ correspond to indices to neighboring triangles.  Neighboring
triangles which correspond to ghost points are represented by a $-1$.  For neighbors
not lying outside boundaries, we must have \\
$0\le$\verb+Neigh1,Neigh2,Neigh3+$<N_c$.\\
Because Suntans determines the number of triangle vertices $N_p$, edges $N_e$, and cells $N_c$
by the number of rows in the \verb+points+, \verb+cells+, and \verb+edges+ files, respectively,
it is important not to have extra carriage returns at the end of these files.

These three files are generated each time the \verb+-t+ flag is used with Suntans.  If
the \verb+-t+ flag is not used, then when called with $\verb+-g+$, Suntans reads these
three files and computes grid geometry and, if desired, partitions it among several processors.
The \verb+-g+ flag outputs the following data files, which are specified in \verb+suntans.dat+.
One file associated with each of these descriptors is created for each processor in a partitioned
grid.  For example, if the file name specified after \verb+cells+ in \verb+suntans.dat+ is given
by \verb+cells.dat+, then when called with 2 processors, the \verb+-g+ flag would output two files
names \verb+cells.dat.0+ and \verb+cells.dat.1+, each corresponding to the \verb+cells+ file of
each processor.
\begin{itemize}
\item \verb+cells+ Same as the output when using \verb+-t+, except on a per-processor basis.
The indices to the triangle vertices still correspond to indices in the global \verb+points+ file, which is
not distributed among the processors.  All other indices are local to the specific processor.
\item \verb+edges+ Same as the output when using \verb+-t+, except on a per-processor basis.
The indices to the end points of the edges still correspond to indices in the global \verb+points+ file, which is
not distributed among the processors.  All other indices are local to the specific processor.
\item \verb+celldata+ Contains the grid data associated with the Voronoi points of each cell and contains
$N_c$ rows, where $N_c$ is the number of cells on each processor (including interprocessor ghost points).
Each row contains the following entries:
\begin{verbatim}
xv yv Ac dv Nk Edge{1-3} Neigh{1-3} N{1-3} def{1-3}
\end{verbatim}
\begin{itemize}
\item \verb+xv yv+ are the Voronoi coordinates
\item \verb+Ac+ is the cell area
\item \verb+dv+ is the depth at the point \verb+xv,yv+.  This is the depth of the bottom-most
face of the column beneath this cell and is not the actual depth, which is always greater than
\verb+dv+.
\item \verb+Nk+ is the number of vertical levels in the water column.
\item \verb+Edge{1-3}+ are indices to the three edges that correspond to the faces of the cell.
\item \verb+Neigh{1-3}+ are the indices to the three neighboring cells.  
\item \verb+N{1-3}+ is the dot product of the unique normal with the outward normal on each
face.
\item \verb+def{1-3}+ is the distance from the Voronoi point to the three faces.
\end{itemize}
\item \verb+edgedata+ Contains the grid data associated with the Delaunay edges and contains
$N_e$ rows, where $N_e$ is the number of edges on each processor (including interprocessor edges).
Each row contains the following entries:
\begin{verbatim}
df dg n1 n2 xe ye Nke Nkc grad{1,2} gradf{1,2} mark xi{1,2,3,4} eneigh{1,2,3,4}
\end{verbatim}
\begin{itemize}
\item \verb+df+ is the length of the edge.
\item \verb+dg+ is the distance between the Voronoi points on either side of the edge.  If 
this is a boundary edge then \verb+dg+ is twice the distance between the edge and the Voronoi
point on the inside of the boundary.
\item \verb+n1,n2+ are the components of the normal direction of the edge.  These correspond
to the {\it unique} normals of each edge.  The outward normal for this edge corresponding to
a particular cell is given by \verb+n1*N, n2*N+, where \verb+N+ is the dot product of the
unique normal with the outward normal and is specified in the \verb+celldata+ file.
\item \verb+xe, ye+ are the coordinates of the intersection of the edge with the Delaunay
edge.  
\item \verb+Nke+ is the number of active edges in the vertical (see \verb+Nkc+).
\item \verb+Nkc+ is the maximum number of active cells in the vertical which neighbor a given edge.  \verb+Nkc+ is
always at least \verb+Nke+.  See Figure \ref{fig:nkenkc} for a graphical depiction.
\insertfig{.5}{figures/nkenkc}{Depiction of an edge in which Nke=4 and Nkc=6.}{fig:nkenkc}
item \verb+grad{1,2}+ are indices to the Voronoi points defined in the \verb+celldata+ file.
If $N_c$ is the number of cells on a processor, then $0\le$\verb+grad{1,2}+$<N_c$.
\item \verb+gradf{1,2}+ are indices that determine the location of the edge in the ordering
of the \verb+Edge{1-3}+ or \verb+def{1-3}+ arrays.  Each cell contains a pointer to this edge
in its list of \verb+Edge{1-3}+ pointers.  The \verb+gradf{1,2}+ index is a number from 
0 to 2 which determines which face number this edge is of a particular cell.
\item \verb+mark+ Contains the marker type for this edge.  All edges with the value 0 are
computational edges, while other values are described in Section \ref{sec:boundary}.
\end{itemize}
\item \verb+topology+
\begin{verbatim}
Np Nneighs neighbor{0,1,2,...,Np-1}\n
neigh0: num_cells_send num_cells_recv num_edges_send num_edges_recv
cell_send_indices ...
cell_receive_indices ...
edge_send_indices ...
edge_recv_indices ...
neigh1: num_cells_send num_cells_recv num_edges_send num_edges_recv
cell_send_indices ...
cell_receive_indices ...
edge_send_indices ...
edge_recv_indices ...
.
.
.
neigh{Numneighs-1}: num_cells_send num_cells_recv num_edges_send num_edges_recv
cell_send_indices ...
cell_receive_indices ...
edge_send_indices ...
edge_recv_indices ...
celldist[0] celldist[1] celldist[2] ... celldist[MAXBCTYPES-1]
edgedist[0] edgedist[1] edgedist[2] ... edgedist[MAXBCTYPES-1]
cellp[0],...,cellp[Nc-1]
edgep[0],...,edgep[Ne-1]
\end{verbatim}
\item \verb+vertspace+ Contains the vertical grid spacings.  This file has \verb+Nkmax+ rows,
where \verb+Nkmax+ is the number of z-levels.
\end{itemize}

\section{Specifying initial and boundary conditions} 

Initial and boundary conditions are specified by editing the files \verb+initial.c+ and \verb+boundaries.c+.  When you
edit either one of these files, you must recompile the Suntans executable in order for it to reflect changes made
to the initial or boundary conditions.

\subsection{Initial conditions}

Initial conditions are set by altering the functions in the file \verb+initial.c+ so that they return the
desired initial distributions.  There are five functions that specify the initial depth, free-surface,
salinity, temperature, and velocity fields.  Each function takes as its argument the x,y,z coordinates of
the desired initial condition.  You need to edit the function to return the desired initial value based on the
given x,y,z coordinates.  The five functions are
\begin{itemize}
\item \verb+ReturnDepth+ This returns the depth as a function of the given x,y coordinate. 
As an example, to set a linear slope that rises from 10 m depth to 1 m depth in 1000 m, the
function would look like
\begin{verbatim}
REAL ReturnDepth(REAL x, REAL y) {
  return 10 - 9*x/1000;
}
\end{verbatim}
Note that the depth is specified as a positive quantity.  This function is only used when the \verb+IntDepth+ variable is
set to \verb+0+ in \verb+suntans.dat+.  Otherwise, the depth is interpolated from the file specified by the \verb+depth+
file in \verb+suntans.dat+.  This file must contain the depth data in three columns given by x, y, depth, where depth
is specified as a negative quantity and elevation is positive.
\item \verb+ReturnFreeSurface+ This returns the initial free surface distribution as a function of the x,y coordinate.
As an example, to initialize the free surface with a 1 m cosine seiche in a 1000 m domain, the function would look like
\begin{verbatim}
REAL ReturnFreeSurface(REAL x, REAL y, REAL d) {
  return cos(PI*x/1000);
}
\end{verbatim}
Note that \verb+PI+ is a global variable defined in the file \verb+suntans.h+ as \verb+3.141592654+.  The depth
is also supplied to the \verb+ReturnFreeSurface+ function in case the free surface is a function of the depth.
\item \verb+ReturnSalinity+ and \verb+ReturnTemperature+  These are similar functions in that they return the
specified scalar field as a function of the x, y, and z coordinates.  Note that if \verb+beta+ is 0 in \verb+suntans.dat+,
then salinity transport is not computed, likewise if \verb+gamma+ is 0, then temperature transport is not computed.  
As it is now, the code computes the temperature as a passive scalar while the density anomaly $\rho$ is computed solely as a function of 
the salinity anomoly $s$, such that
\[\frac{\rho}{\rho_0}=\beta s\,.\]
\item \verb+ReturnHorizontalVelocity+ This returns the horizontal velocity defined at the faces of each cell.  The initial vertical velocity is
computed by continuity from this initial velocity field.  Since this function returns the velocity normal to a cell face, then
you must specify both velocity components \verb+u+ and \verb+v+ and then return the component normal to the face, which is
defined by the vector with components \verb+n1+ and \verb+n2+.  As an example, to return an irrotational vortex with
maximum velocity of 1, centered
about (x,y)=(5,5), the function would appear as
\begin{verbatim}
REAL ReturnHorizontalVelocity(REAL x, REAL y, REAL n1, REAL n2, REAL z) {
  REAL u, v, umag=1;

  u = -umag*(y-5)/5;
  v = umag*(x-5)/5;

  return u*n1+v*n2;
}
\end{verbatim}
\end{itemize}

\subsection{Specifying boundary conditions} \label{sec:boundary}

Suntans allows the specification of the velocity at the open boundaries in the file
\verb+boundaries.c+.  Boundary condition types on the velocity field can be specified in the \verb+pslg+ file
which sets the marker as described in Sections \ref{sec:tri} and \ref{sec:readgrid}.  The marker type
can be one of the following:
\begin{itemize}
\item \verb+1+ For closed boundaries.
\item \verb+2+ For open or velocity-specified boundaries.
\end{itemize}
If the marker is set to \verb+1+, then the velocity is set to \verb+0+ at those edges.  If it is set to \verb+2+,
then the velocity is specified in the file \verb+boundaries.c+.  This file loops through the edges whose edge
markers are \verb+2+.  As an example, consider the flow in a channel that is 1000 m long in which two boundaries
are specified as inflow and outflow and the other two are specified as solid walls, as shown in Figure 
\ref{fig:boundaries}.  
\insertfig{.5}{figures/boundaries}{Depiction of a channel with an inflow at $x=0$ m and outflow at $x=1000$ m with
the inflow/outflow boundaries specified with 2 markers and the solid walls with 1 markers.  The indices of
the cells adjacent to the boundaries are denoted by ib while the boundary cells have indices j.}{fig:boundaries}
Suppose you would like to
specify an incoming velocity that oscillates at a frequency $\omega$ due to an incoming wave at $x=0$ m and that
you would like to use the linearized open boundary condition to specify the outflow at $x=1000$ m.  Since the
edge markers at the inflow and outflow are the same, you need to set the boundary condition based on the x,y
location of the specified edge.  To do so, you would set up the \verb+boundaries.c+ file as follows
\begin{verbatim}
  .
  .
  .

  for(jptr=grid->edgedist[2];jptr<grid->edgedist[3];jptr++) {
    j = grid->edgep[jptr];

    ib = grid->grad[2*j];

    if(grid->xv[ib]>500) {
      forced=0;
      for(k=grid->etop[j];k<grid->Nke[j];k++) 
        uboundary[k] = -phys->h[ib]*sqrt(GRAV/(grid->dv[ib]));
    } else {
      forced=1;
      for(k=grid->etop[j];k<grid->Nke[j];k++) 
        uboundary[k] = prop->amp*cos(prop->omega*prop->rtime);
    }
    .
    .
    .
\end{verbatim}
The outermost \verb+j+ loop loops over the edges which have boundary markers specified as \verb+2+.
The \verb+ib+ index is an index to the cell adjacent to the boundary edge.  Since the Voronoi points
are specified at the \verb+ib+ indices, then we need to specify the boundary condition based on
the location of the Voronoi points of the adjacent cell.  In this case the open boundary exists at x=1000, but since
we know that this boundary exists for boundary edges for $x>500$, we use the if statement
\verb+if(grid->xv[ib]>500)+ to specify these boundary edges.  The first part of the if statement
sets the velocity at the open boundary over all the vertical levels with
\begin{verbatim}
      forced=0;
      for(k=grid->etop[j];k<grid->Nke[j];k++) 
        uboundary[k] = -phys->h[ib]*sqrt(GRAV/(grid->dv[ib]));
\end{verbatim}
which is identical to 
\[ u_b = -h_b\sqrt{\frac{g}{d}} \,,\]
which is the linearized shallow-water free-surface boundary condition.  The variable \verb+forced+ is
set to \verb+0+ for this boundary because it is used later when the velocity at the boundary is set
to the value in the \verb+uboundary[k]+ array.  If \verb+forced+ is \verb+0+, then the velocity is nudged
towards this value over a timescale specified by the \verb+timescale+ variable in \verb+suntans.dat+.  
The boundary condition on the velocity $u_j$ is then effectively
\[\D{u_j}{t} = \frac{u_j-u_b}{\tau}\,,\]
where $u_b$ is specified by \verb+uboundary[k]+ and $\tau$ is specified by \verb+timescale+.  

For the case in which the if-statement fails, then the edges for which $x<500$ are specified with
\begin{verbatim}
      forced=1;
      for(k=grid->etop[j];k<grid->Nke[j];k++) 
        uboundary[k] = prop->amp*cos(prop->omega*prop->rtime);
\end{verbatim}
Here \verb+forced+ is set to zero so that the boundary condition is not nudged to this value over
the specified timescale so that effectively
\[u_j = u_b\,,\]
where \verb+u_b+ is set by \verb+uboundary[k]+.  In the above code, the boundary value is set to
\[u_b = a\cos(\omega t)\,,\]
where the amplitude $a$ of the forcing is specified by the \verb+amp+ variable in \verb+suntans.dat+,
the frequency $\omega$ is set by \verb+omega+, and the time is computed and set by the \verb+rtime+ 
variable.  Each of these are accessed by the \verb+prop+ struct with \verb+prop->amp+, \verb+prop->omega+,
and \verb+prop->rtime+.  Note that if the velocity is into the domain, then it must be positive, while
if it is out of the domain, it must be negative.

\section{Using the Sunplot GUI}

\section{Restarting Runs} \label{sec:restart}

It is always a good idea to design production-scale runs so that at any point in time if your
job crashes you can restart it without having lost too much data.  At the end of a run, Suntans
outputs the restart file specified by \verb+StoreFile+ in \verb+suntans.dat+.  To restart a run using
this restart file, you need to copy this file into the file specified by \verb+StartFile+ in \verb+suntans.dat+.
This reads the data required to continue a run.  For example, at the end of a two-processor run in which
the \verb+StoreFile+ variable is set to \verb+store.dat+, two restart files are created for each processor, 
namely \verb+store.dat.0+ and \verb+store.dat.1+.  To restart this run, set the entry for \verb+StartFile+ in
\verb+suntans.dat+ to \verb+start.dat+ and copy \verb+StoreFile+ to \verb+StartFile+ for each processor, i.e.
copy the contents of \verb+store.dat.0+ to \verb+start.dat.0+ and \verb+store.dat.1+ to \verb+start.dat.1+.

Since the new output data from the restart run will overwrite any existing data from a previous run, it is
a good idea to create a new directory for each restart run and copy the restart files into that directory.
Each run requires the \verb+suntans.dat+ file as well as other files for the grid as well, but rather than
copy these over to the new directory, it is best to create links to the already existing files in order
to save disk space.  In order for the restart run to proceed, links must be created for each of these
files (or copies):
\begin{itemize}
\item suntans.dat
\item celldata.dat.np
\item edgedata.dat.np
\item topology.dat.np
\item vertspace.dat
\end{itemize}
where \verb+np+ corresponds to each processor id.  Considering the previous example, to restart a run
one might create a new directory called \verb+run2+.  Then links could be made to the existing files 
with
\begin{verbatim}
ln -s suntans.dat run2/suntans.dat
ln -s celldata.dat.0 run2/celldata.dat.0
ln -s celldata.dat.1 run2/celldata.dat.1
ln -s edgedata.dat.0 run2/edgedata.dat.0
ln -s edgedata.dat.1 run2/edgedata.dat.1
ln -s topology.dat.0 run2/topology.dat.0
ln -s topology.dat.1 run2/topology.dat.1
ln -s vertspace.dat run2/vertspace.dat
\end{verbatim}
and then restarting Suntans (after copying the store files into run2) with
\begin{verbatim}
mpirun -np 2 sun -s -r --datadir=./run2
\end{verbatim}
where the \verb+r+ flag indicates a restart run.  An alternative method to perform a restart
is to create a new directory and then alter the entries in \verb+suntans.dat+ so that the
output files are specified by their full rather than relative paths.  For example, to set
the output directory so that Suntans outputs the free surface to the new directory \verb+run2+,
the entry for \verb+FreeSurfaceFile+ in \verb+suntans.dat+ could be changed from
\begin{verbatim}
FreeSurfaceFile   	fs.dat
\end{verbatim}
to
\begin{verbatim}
FreeSurfaceFile   	run2/fs.dat
\end{verbatim}

\appendix

\section{Parameter listing} \label{app:params}

\bibliographystyle{plain}
\bibliography{/home/fringer/latex/bibliography}

\end{document}

\section{Using the Sunplot GUI}

\section{Input/Output Files}

\subsection{Grid}

\subsubsection{Inputs}

\begin{itemize}
\item PSLGFILE[BUFFERLENGTH], 
\item File designator: {\bf depth}
\begin{itemize}
\item Array name: \verb+INPUTDEPTHFILE+
\item Default file name: \verb+depth.dat+
\item Format: \verb+xd yd d+
\item Description: Contains values for depths to be interpolated onto the Voronoi points.
The number of rows is dependent upon the number of data points.  For example, if a 
$100\times 100$ set of bathymetry is available, it must be written to this file
in $10 000$ rows for use in the interpolation.
\item Size: See above.
\item Type: ASCII
\end{itemize}
\end{itemize}

\subsubsection{Inputs and Outputs}

\begin{itemize}
\item File designator: {\bf points}
\begin{itemize}
\item Array name: \verb+POINTSFILE+ 
\item Default file name: \verb+points.dat+
\item Format: \verb+xp[Np] yp[Np]+ 
\item Description: Stores the Voronoi points for the entire domain
\item Size: $N_p$ rows.
\item Type: ASCII
\end{itemize}
\item File designator: {\bf edges}
\begin{itemize}
\item Array name: \verb+EDGEFILE+ 
\item Default file name: \verb+edges.dat.Np+
\item Format: \verb+edgep1 edgep2 edgemarker+
\item Description: Indices to points in the \verb+points+ file and marker type.  Without the trailing
processor number, \verb+edges.dat+ contains all the edge pointers for the entire triangulation.  With
the trailing processor number, the format is of the form \verb+edgep1 edgep2 mark grad1 grad2+
\item Size: $N_e$ rows ($N_e$ is total for entire grid without trailing processor number,
$N_e$ is total for particular processor with the trailing processor number).
\item Type: ASCII
\end{itemize}
\item File designator: {\bf cells}
\begin{itemize}
\item Array name: \verb+CELLSFILE+ 
\item Default file name: \verb+cells.dat.Np+
\item Format: \verb+xv yv cellp1 cellp2 cellp3 neigh1 neigh2 neigh3+
\item Description: \verb+xv+ and \verb+yv+ are the voronoi points, \verb+cellp1,2,3+ are the indices to points
in the \verb+points+ file, and \verb+neigh1,2,3+ are the indices to cell neighbors.
\item Size: $N_c$ rows
\item Type: ASCII
\end{itemize}
\end{itemize}

\subsection{Physical Data}

\appendix

\section{Parameter listing} \label{app:params}

\subsection{General variables for the sun executable}

\begin{tabular}{p{1.25in}p{5in}}
\verb+Nkmax+ & The number of vertical grid cells.\\
\verb+stairstep+ & Type of vertical grid to use.  1: stair-stepping, 0: partial-stepping\\
\verb+rstretch+ & Stretching factor for vertical grid (1<=rstretch<1.1)\\
\verb+CorrectVoronoi+ &  Whether or not to correct Voronoi points\\
\verb+VoronoiRatio+ &  Adjust the voronoi points by this amount if 1 then = centroid.\\
\verb+vertgridcorrect+ &  Correct vertical grid if Nkmax is too small\\
\verb+IntDepth+ &  1 if interpdepth, 0 otherwise\\
\verb+dzsmall+ &  Smallest grid spacing ratio before correction\\
\verb+scaledepth+ &  Scale the depth by scalefactor\\
\verb+scaledepthfactor+ &  Depth scaling factor (to test deep grids with explicit methods)\\
\verb+thetaramptime+ &  Timescale over which theta is ramped from 1 to theta (fs theta only)\\
\verb+theta+ &  0: fully explicit, 1: fully implicit\\
\verb+thetaS+ &  For scalar advection\\
\verb+thetaB+ &  For scalar advection\\
\verb+beta+ &  Coefficient of expansivity of salt.\\
\verb+kappa+ &  Vertical mass diffusivity\\
\verb+kappa+ &  Horizontal mass diffusivity\\
\verb+gamma+ &  Coefficient of expansivity of temperature.\\
\verb+kappa+ &  Vertical thermal diffusivity\\
\verb+kappa+ &  thermal diffusivity\\
\verb+nu+ &  Vertical laminar viscosity of water (m$^2$ s$^{-1}$)\\
\verb+nu+ &  Horizontal laminar viscosity of water (m$^2$ s$^-1$)\\
\verb+tau+ &  Wind shear stress\\
\verb+CdT+ &  Drag coefficient at surface\\
\verb+CdB+ &  Drag coefficient at bottom\\
\verb+CdW+ &  Drag coefficient at sidewalls\\
\verb+dt+ &  Time step\\
\verb+Cmax+ &  Maximum permissible Courant number\\
\verb+nsteps+ &  Number of steps (3000 per M2 tide)\\
\verb+ntout+ &  How often to output data\\
\verb+ntprog+ &  How often to report progress (in \%)\\
\verb+ntconserve+ &  How often to output conserved data\\
\verb+nonhydrostatic+ &  0 = hydrostatic, 1 = nonhydrostatic\\
\verb+cgsolver+ &  0 = GS, 1 = CG\\
\verb+maxiters+ &  Maximum number of CG iterations\\
\verb+qmaxiters+ &  Maximum number of CG iterations for nonhydrostatic pressure\\
\verb+qprecond+ &  1 = preconditioned, 0 = not preconditioned\\
\verb+epsilon+ &  Tolerance for CG convergence\\
\verb+qepsilon+ &  Tolerance for CG convergence for nonhydrostatic pressure\\
\verb+relax+ &  Relaxation parameter for GS solver.	\\
\verb+amp+ &  amplitude\\
\verb+omega+ &  frequency\\
\verb+flux+ &  flux\\
\verb+timescale+ &  timescale for open boundary condition\\
\verb+volcheck+ &  Check for volume conservation\\
\verb+masscheck+ &  Check for mass conservation\\
\verb+nonlinear+ &  1 if nonlinear advection for horizontal velocity, 0 for u$^{n+1}=u^n$\\
\verb+newcells+ &  1 if adjust momentum in surface cells as the volume changes, 0 otherwise\\
\verb+wetdry+ &  1 if wetting and drying, 0 otherwise\\
\verb+Coriolis+ &  Coriolis frequency f=2*Omega*sin(phi)\\
\verb+sponge+ &  Decay distance scale for sponge layer\\
\verb+sponge+ &  Decay time scale for sponge layer
\end{tabular}

\subsection{General variables for sunplot}

\begin{tabular}{p{1.5in}p{5in}}
\verb+caxisminU+ &  minimum caxis value for horizontal U velocity\\
\verb+caxismaxU+ &  maximum caxis value for horizontal U velocity\\
\verb+caxisminV+ &  minimum caxis value for horizontal V velocity\\
\verb+caxismaxV+ &  maximum caxis value for horizontal V velocity\\
\verb+caxisminW+ &  minimum caxis value for horizontal W velocity\\
\verb+caxismaxW+ &  maximum caxis value for horizontal W velocity\\
\verb+caxisminS+ &  minimum caxis value for horizontal Salinity\\
\verb+caxismaxS+ &  maximum caxis value for horizontal Salinity\\
\verb+caxisminDefault+ &  default min\\
\verb+caxismaxDefault+ &  default max
\end{tabular}

\subsection{Grid input/output files}

\begin{tabular}{p{1in}p{5in}}
\verb+pslg+ &  Planar straight line graph (input)\\
\verb+points+ &  Vertices file (input)\\
\verb+edges+ &  Edge file (input)\\
\verb+cells+ &  Cell centered file (input)\\
\verb+depth+ &  Depth file for interpolation (if INTERPDEPTH=1) (input)\\
\verb+celldata+ &  Cell-centered output (output)\\
\verb+edgedata+ &  Edge-centered output (output)\\
\verb+vertspace+ &  Vertical grid spacing (output)\\
\verb+topology+ &  Grid topology data\\
\end{tabular}

\subsection{Output Data Files}

\begin{tabular}{p{.5in}p{6in}}
\verb+FreeSurfaceFile+   	& \\
\verb+HorizontalVelocityFile+ 	& \\
\verb+VerticalVelocityFile+ 	& \\
\verb+SalinityFile+ 		& \\
\verb+BGSalinityFile+ 		& \\
\verb+TemperatureFile+		& \\
\verb+PressureFile+		& \\
\verb+VerticalGridFile+ 	& \\
\verb+ConserveFile+		& \\
\verb+ProgressFile+	        & \\
\verb+StoreFile+		& \\
\verb+StartFile+		&
\end{tabular}

\bibliographystyle{plain}
\bibliography{/home/fringer/latex/bibliography}

\end{document}




celldata & \verb+CELLCENTEREDFILE+ & celldata.dat.Np
& xv yv Ac dv Nk face1 face2 face3 neigh1 neigh2 neigh3 normal1 normal2 normal3 def1 def2 def3 (ffffiiiiiiiiiifff) & $N_c \times 17$ ASCII\\
edgedata & \verb+EDGECENTEREDFILE+ & edgedata.dat.Np
& df dg n1 n2 xe ye Nke Nkc grad2n grad2np1 grad2n grad2np1 mark (ffffffiiiiiii) & $N_e \times 13$ & ASCII\\
vertspace & \verb+VERTSPACEFILE+ & vertspace.dat.Np
& dz (f) & $N_{kmax}\times 1$ & ASCII\\
topology & \verb+TOPOLOGYFILE+ & topology.dat.Np
& \verb+numprocs+ \verb+Nneighs+ \verb+myneighs[Nneighs]+
\verb+num_cells_send[Nneighs]+ \verb+num_cells_recv[Nneighs]+
\verb+num_edges_send[Nneighs]+ \verb+num_edges_recv[Nneighs]+
\verb+cell_send[Nneighs][num_cells_send[Nneighs]]+ \verb+cell_recv[Nneighs][num_cells_recv[Nneighs]]+
\verb+edge_send[Nneighs][num_edges_send[Nneighs]]+ \verb+edge_recv[Nneighs][num_edges_recv[Nneighs]]+
\verb+celldist[MAXBCTYPES]+ \verb+edgedist[MAXMARKS]+ \verb+cellp[Nc]+ \verb+edgep[Ne]+
& - & ASCII \\
\end{tabular}